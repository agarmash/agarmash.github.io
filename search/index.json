[{"content":"The Original Xbox was a total disaster from a security point of view. It has been fully cracked relatively quickly, so it became possible to modify your system to disable the security checks and run the unsigned code: Linux, homebrew, game backups - you name it.\nFor making that possible for the end user, 2 modding methods have been created:\nHardmod - requires soldering a modchip to the mainboard that contains the modified BIOS with security checks disabled and overrides the built-in flash memory. This is the most reliable and fool-proof method, but it requires modifying the hardware; Softmod - requires triggering a chain of exploits in software. Usually, a commercially available videogame with exploitable vulnerabilities in the savefile loading code is used as an entry point. Less reliable since the console can be bricked by doing something wrong (however, hardmod would fix it in any case), but doesn\u0026rsquo;t require any soldering iron involvement. Even today, the softmod is a preferred method for a lot of people, so we\u0026rsquo;re going to take a look at how some parts of the softmod work, and create a brand new savefile exploit.\nAttack surface The Xbox kernel is based on Windows 2000. However, a lot of the features have been stripped, including multitasking, so only a single executable is running at the time. Moreover, every executable is running with kernel privileges, to squeeze a few extra bits of performance. On top of that, The system is based on the Intel Pentium 3 CPU, which doesn\u0026rsquo;t have an NX-bit feature, so all the memory pages are executable. This makes the process quite straightforward - once we hijacked the program execution, we ultimately have control over the whole system.\nVanilla Xbox can ultimately run one of the following pieces of software:\nDashboard - starts if there\u0026rsquo;s no game disc present in the optical drive. Has its share of vulnerabilities, however, none of them is possible to trigger from the unmodified state; Videogame - loaded from a DVD disc with lots of copy protection measures, contains an RSA signed executable (as well as every other official executable), can load and store savefiles from/to built-in HDD or a memory card. Savefiles are of particular interest to us:\nOften they store string values (like the player\u0026rsquo;s name) in form of null-terminated C strings. If the game doesn\u0026rsquo;t validate the length of the string, there\u0026rsquo;s a potential buffer overflow we can exploit; Savefiles are the only adequate option to provide the initial shellcode that will be executed after hijacking a program control flow. Microsoft clearly didn\u0026rsquo;t want anyone to tamper with the savefiles, so they obliged the game developers to incorporate a digital signature into every savefile and to check it on loading. They even provided a convenient API for doing that. However, after the system has been cracked, people discovered that the algorithm for generating signature looks like that:\nderived_key = HMAC(game_key, xbox_key, SHA1) signature = HMAC(derived_key, savefile_data, SHA1) The aforementioned xbox_key is the key that is stored in the system software and is unique for every console, the game_key is the key that is stored in the game executable\u0026rsquo;s header and is unique to every game. It\u0026rsquo;s also possible to tie the savefile to the particular console by adding the per-console key to the mix. In Microsoft terminology it\u0026rsquo;s called a \u0026ldquo;non-roamable signature\u0026rdquo;, you can learn more about it here in my other post.\nThis gives us enough information to start exploring games for vulnerabilities. However, there are some more topics to cover first.\nExisting savefile exploits It shouldn\u0026rsquo;t be a surprise that this kind of exploit has been implemented multiple times. Let\u0026rsquo;s take a look at the existing ones:\n007: Agent Under Fire (March 2003) - The first one released. Created by habibi_xbox (David Jilli). Shellcode is encrypted and the decryption code is heavily obfuscated. The decryptor can be found here. Technical breakdown is available here; MechAssault (June 2003) - Released soon after the 007 exploit. Shellcode is similar to the 007 and is stored as plaintext; Splinter Cell (December 2003) - released at the 20th Chaos Communication Conference (20C3) by Andrew \u0026ldquo;bunnie\u0026rdquo; Huang and Michael Steil of the Xbox-Linux project. Shellcode differs from the previous exploits (more about that later). It is also encrypted with a simple XOR cipher, most likely to remove the zero bytes from the binary to copy it a part of the string. The decryptor can be found here; Tony Hawk 4 (April 2017) - created by Grimdoomer. The shellcode looks similar to the decrypted one from the Splinter cell. Metal Arms (January 2022) - created by dj0wns (Derek Jones). The first half of the shellcode seems to be borrowed from the 007 exploit. Uses some format string vulnerabilities as well to achieve code execution. Now, there\u0026rsquo;s an interesting bit. During his talk at the 22C3, Michael Steil mentioned Frogger Beyond among the rest of the exploited games. However, this is the only mention of this game, and there\u0026rsquo;s no exploit in public for it. And since I was already playing with the Xbox internals, I decided to figure out how can the Frogger be exploited.\nPrerequisite: debug hardware It would be quite hard to learn about the program internals and to craft an exploit without a debugger. Fortunately for us, it\u0026rsquo;s possible to convert a retail Xbox into a debug kit by adding the SuperIO board to get the serial port connectivity and by running the debug system software. After doing that, you can debug the Xbox with WinDbg kernel debugger. Here\u0026rsquo;s a good reference of the WinDbg commands.\nDebug conversion is out of the scope of this article, but this is how my Xbox ended up hardware-wise:\nExamining the game for a possible overflow Time to get our hands dirty.\nFirst of all, let\u0026rsquo;s boot the game and play a bit until the game allows us to save the progress. After saving the game, transferring the savefile from the console, and opening it with a hex editor, we can see the following:\nThe file starts with a magic byte 0x01, after that comes the player name if the form of a null-terminated string, and after that there are some sparse bits of data. The rest is just zeros, and the last 20 bytes are the signature.\nNow the obvious thing for us to do is to fuzz the string. We extend the string with a long non-null pattern of bytes, sign the savefile, copy it to the console, and let the game try to load it:\nUnsurprisingly, the game crashes with Access violation: writing to location 0x07070723, which indicates that we probably overwrote some pointer in the local stack frame which got used before returning from the function:\nBy playing with the long string contents I figured out that the pointer is overwritten with the bytes at the offset 0x159-0x15C in the savefile.\nThe debugger also shows us the call stack during the exception, the top entries of which are 0xd68ef and 0xdd51e (and the rest is a corrupted stack):\nAnother thing we can do is to search the RAM for the loaded savefiles. Fortunately for us, the game loads the first savefile to the memory address 0x00429918:\nConveniently, the address remains the same between the reboots, so we don\u0026rsquo;t need to copy our payload as part of the string, it\u0026rsquo;s already waiting for us in the memory.\nExamining the executable internals Now, let\u0026rsquo;s fire up Ghidra and take a look at what\u0026rsquo;s going on in the game executable by the addresses from the call stack.\nFirst comes the function containing the offset 0xdd51e. In short, there\u0026rsquo;s a big function for handling a lot of different stuff related to loading the savefiles of the game. Let\u0026rsquo;s skip the Assembly and go straight to the decompilation of the interesting part. The instruction at the aforementioned offset is the next one after the CALL to the my_presentAlert function. Oh, by the way, all the symbols are stripped from the executable, what you see is what I was able to recover:\nThe interesting lines are 344-346. Here we can see that the string is formatted and copied to the local_170 buffer, and the function my_prepareAlert is being called with the pointer to the local_170 as one of its parameters.\nAfter examining the executable with Ghidra and the memory of the running game with WinDbg, we can recreate the interesting part of the stack frame of this function:\nAs you can see, there is a local_170 buffer that we can overflow, some other local variables we\u0026rsquo;re not interested in, a this_ pointer to an instance of some game class, saved EBP value, and the return address.\nNow let\u0026rsquo;s take a look at the function containing the offset 0xd68ef. It contains the logic related to presenting the on-screen alert. In our case, it gets called with the following parameters:\nthis: pointer to memory selector: 2 message: pointer to memory unknown1: 0 unknown2: 0 This is what the result of its decompilation looks like:\nThe instruction at the aforementioned offset is represented by the line 6. It aligns perfectly with the \u0026ldquo;Access violation\u0026rdquo; exception - we corrupted the pointer and tried to write something to some invalid address.\nSince at this point we\u0026rsquo;re not planning to return back to the running game, we can just overwrite this_ pointer with some \u0026ldquo;safe to write to\u0026rdquo; address (e.g. a higher address in the stack, like 0xd014a9b0) and check if the game \u0026ldquo;survives\u0026rdquo; until returning from the dd51e function. Running the game step-by-step in the debugger shows that it happily reaches the end of the function and tries to return to the address that we overwrote. Perfect.\nNow it\u0026rsquo;s time to take a step aside and think what code we want to execute after hijacking the execution flow, aka the shellcode.\nShellcode Generally, a shellcode should achieve 2 goals:\nCircumvent the RSA signature check of the executable; Run the unsigned executable that is provided as part of the savefile package. To achieve that, shellcode does the following:\nDisables memory write protection: Achieved by clearing out the Write Protect bit in the CR0 register. As the Intel® 64 and IA-32 Architectures Software Developer Manual, Vol. 3A describes it, \u0026ldquo;when set, inhibits supervisor-level procedures from writing into read-only pages; when clear, allows supervisor-level procedures to write into read-only pages\u0026rdquo;. Conveniently, we\u0026rsquo;re already running in ring 0, so all the memory magically becomes writable! another way to do that is kinda obscure. As Thrimbor said (message screenshot), it looks like pathing the R/W bit of page table entries from the offset 0xc0200000; Patches the RSA key. The original 007 exploit tried to limit the use of the exploit to Linux booting only. Instead of disabling the signature check, the author decided to change the last 4 bytes of the public key. The resultant key is divisible by 3, which makes it easily factorable, which in turn allows us to retrieve the private key and sign our own executables. This pair of keys is called \u0026ldquo;habibi\u0026rdquo; after the nickname of the author of the original exploit habibi_xbox (David Jilli). There are multiple approaches to patching the key: Search for the key in the kernel address space. That was the original method of doing that - the exploit does a linear search for the last for 4 bytes of the key in memory, and patches them once they are found; Get the address of the kernel structure which holds the public key from the kernel exports table. After getting the address, we just patch the bytes at the known offset from the beginning of the structure; Launches the provided executable. It can also be done in several ways: By calling the XAPI methods. First, the DVD drive should be unmapped from the \u0026ldquo;D:\u0026rdquo; drive and the partition containing the game saves should be mapped to D: instead. This is done since XAPI will refuse to launch an executable from the drive different from D:. It can be achieved by calling IoDeleteSymbolicLink and IoCreateSymbolicLink kernel functions respectively. After that, it\u0026rsquo;s possible to run the XLaunchNewImage XAPI function to run the executable. The main downside of this method is that we need to know the offset of the statically linked XAPI inside the executable, which makes the exploit non-portable. Used by 007 and MechAssault exploits; By calling the kernel methods directly. This is what the XLaunchNewImage XAPI function does under the hood. An example code can be found in the OpenXDK repository. In contrast, this code is portable between the executables, and doesn\u0026rsquo;t even require the target executable to be statically linked against XAPI. Achieved by: Getting the address of the memory page containing LaunchDataPage kernel structure; Allocating the new memory page if the pointer is NULL by calling MmAllocateContiguousMemory; Saving the pointer back in the kernel by calling MmPersistContiguousMemory; Zeroing out the memory page and setting it up with the required parameters, including the path to the executable; Calling HalReturnToFirmware with the parameter ReturnFirmwareQuickReboot. In addition, exploits that disable memory write protection through the CR0 register are combining the write protection disabling and the key patching inside the critical section, achieved by temporarily disabling the CPU interrupts. Some of the exploits also invalidate TLB and flush the CPU caches as a precaution.\nThe table below shows which exploit uses which of the described approaches:\n007 MechAssault Splinter Cell Tony Hawk 4 MetalArms Disabling memory write protection Page table patching CR0 CR0 CR0 Page table patching Public key patching Search for the key Known offset Known offset Known offset Search for the key Launching the executable XAPI XAPI Kernel calls Kernel calls Kernel calls Critical section No Yes Yes Yes No Invalidates TLB No Yes (twice) Yes (twice) No No Flushes CPU caches No Yes Yes No No Choosing a shellcode Well, there are plenty of options to choose from. We can construct our own shellcode using parts of the existing ones, or just adapt an existing shellcode to our purposes. However, it\u0026rsquo;s not really convenient to do that.\nFortunately, we can take a slightly different route. There is a dashboard exploit called Bert \u0026amp; Ernie that exploits a vulnerability in the font loading code. I wasn\u0026rsquo;t able to find the original exploit, but what I found instead is an offshoot of this exploit as part of the NKPatcher 11 tool in Rocky5\u0026rsquo;s softmod repository. It has all the pieces of the shellcode described above. More importantly, its Assembly source code is available. This basically makes it a DIY kit for our own exploit, especially since the code is portable due to the absence of the XAPI calls. In my exploit, I\u0026rsquo;m going to use this shellcode with some modifications.\nReturning to shellcode Now since we have all the required bits, it\u0026rsquo;s time for us to create an exploited savefile. We achieve that by doing the following:\nFill the gap from the end of the profile name to the offset 0x158 with any non-zero values. The key is to not have a zero byte (C string terminator) until we overwrote all the interesting things on the stack; Put the overwrite value of this_ at the offset 0x159 of the savefile. As mentioned before, we\u0026rsquo;re overwriting it with a higher address on the stack, 0xd014a9b0; Put the overwrite value of the saved EBP next, at the offset 0x15d. This should be overwritten with any non-zero values, let\u0026rsquo;s put 0xdeadf00d there for additional points of style; Put the return address next, at the offset 0x161. We\u0026rsquo;ll figure it\u0026rsquo;s value a tiny bit later. Put a zero byte next, at the offset 0x165 to finally terminate the string. In our case, we don\u0026rsquo;t need to copy any more bytes; Put a reasonably large NOP slide somewhere in the rest of the file followed by the shellcode. Since we don\u0026rsquo;t directly control the address in memory where the whole savefile is loaded, it\u0026rsquo;s better to have a NOP slide in case the data moves a bit in memory. Now let\u0026rsquo;s go back to the return address. The savefile is loaded to the address 0x00429918. By picking the address of the middle of the NOP slide in the savefile and adding it to the address above, I got a value of 0x00429bd2. This creates a problem for us. Since the x86 CPU is little-endian, the address would be written backwards in the file, like d2 9b 42 00 (as well as the rest of the values). As we remember, we can\u0026rsquo;t include zero bytes in the string, since this is a string terminator. However, this is the last byte that we need to copy, so that should be fine, it will be both the most significant byte of the address and the string terminator.\nThis is what the end result looks like:\n(Note that all the addresses are written as little-endian values)\nSo, let\u0026rsquo;s sign our carefully crafted savefile, transfer it to the console and boot the game.\nUnfortunately, the game just hangs after trying to load the savefile. The debugger shows that the game tries to execute something from the invalid address 0x3f429bd2 which crashes the system.\nWait, why did the most significant byte become 0x3f instead of 0x00? Let\u0026rsquo;s take a look at the format parameter of the my_sprintf. Its value is \u0026quot;Confirm Load of %s?\u0026quot;, and as you can see, a question mark is added right after the string we\u0026rsquo;re controlling. The most significant byte of the return address effectively terminates our string, and the sprintf happily adds a question mark right after, which ASCII code is, as you may have guessed, 0x3f! This single byte is literally the only thing that blocks us from exploiting the executable like that. Let\u0026rsquo;s see what else can we do.\nPlan B: bootstrap loader The nice property of the stack is that it\u0026rsquo;s located in the part of the address space way above the address 0x00xxxxxx. We can write a small bootstrap loader that will construct the desired address in memory and jump there. The most important property of this bootstrap is not to contain zero bytes, so we can copy it to the stack as part of the string.\nThis is the code I ended up with:\nmov eax, 0FEEDC0DEh mov ebx, 0FEAF5B0Ch xor eax, ebx jmp eax The address is stored as a product of XORing it with a constant (0xfeedc0de xor 0x00429bd2 = 0xfeaf5b0c). Since (a xor b) xor b = a the address is recovered by XORing the product with the same constant once again. After that, it\u0026rsquo;s just a matter of jumping to the recovered address. The compiled bootstrap looks like b8 de c0 ed fe bb 0c 5b af fe 31 d8 ff e0, so it perfectly matches the requirement of not having any zero bytes.\nReturning to shellcode, take 2 Now we\u0026rsquo;re gonna do the following:\nInclude the bootstrap loader as part of the copied string; Figure out its location in the stack with the debugger and put this address into the overwritten return address. This is how it looks like:\nAfter booting the game and trying to load the resultant savefile, I was greeted with a kernel exception UNEXPECTED_KERNEL_MODE_TRAP with the first parameter meaning \u0026ldquo;Double fault\u0026rdquo;:\nThe return address however has been overwritten correctly, so the problem lies in a different place. (To be presice, I got this exception previous time as well. However, it wasn\u0026rsquo;t really important there.)\nXbox address space The retail Xbox has 64 MB of RAM, mapped from 0x00000000 to 0x03ffffff. Stack addresses are clearly out of this range, which means that those are virtual addresses. This leads us to the conclusion that the Xbox kernel doesn\u0026rsquo;t support executing the code from the virtual addresses, so we have to stick to the physical addresses.\nSince we can\u0026rsquo;t return to the address containing zero bytes, the first accessible address is 0x01010101, located at 16-something MB from the beginning. Excluding the rest of the addresses containing zero byte, we have the access to around ~40 MB of RAM.\nThe possible next steps would be:\nLooking for the gadgets in the accessible areas of RAM and constructing the ROP chain (however, there\u0026rsquo;s no guarantee that the values used for gadgets are gonna be the same on every system and on every boot); Finding another vulnerability we can leverage. Let\u0026rsquo;s try the second option and see where it will lead us.\nLooking for another vulnerability After taking a break and looking at the my_presentAlert function with fresh eyes, it hit me - we control the value of this, and the function does some writes to the addresses relative to it. Let\u0026rsquo;s recap the passed parameters and the decompiled function itself:\nthis: pointer that we control selector: 2 message: pointer to the string that we control unknown1: 0 unknown2: 0 At first, I was examining if I can leverage single-byte writes to the relative offsets 0x1c-0x1f and 0x27, but they were barely useable in the given situation. And then I noticed the line 29. This call to _strcpy does precisely what you think - it copies the string we control to the address we control! This is a huge one! Let\u0026rsquo;s see how we can leverage it.\nReturning to shellcode, take 3 Our course of action would be:\nTo find a place in RAM where we can write our string containing the bootstrap; The rest at this point is obvious. For the kicks and giggles, I tried overwriting the value of this with the first available physical address, 0x01010101. This is what I saw with the debugger:\nThe arbitrary write worked! The selected area is nothing but our bootstrap loader! Perfect!\nNow we can do the following:\nOverwrite this_ with 0x01010101; Figure out the address of the shellcode in the string copied to the physical address, and overwrite the return address with this value. In my case, it was 0x01010281 (can be figured out with a debugger or calculated manually by adding the offset in the _strcpy call (0x51), length of the format string before the %s in the my_sprintf call (0x10), and the offset to the bootstrap from the beginning of the string in the savefile (in my case, 0x11f) to the value of this_). Finally, it worked! Here\u0026rsquo;s a short demo of the exploit in action:\nThis is how the final savefile looks like:\nThe missing part only contains the rest of the NOP slide. Sources of the exploit with the extensive comments can be found here, as well as the ready to use exploit.\nPlease note that I tested the exploit on the modified Xbox. If you try to use it on a vanilla Xbox and something doesn\u0026rsquo;t work, let me know so we can fix it for everyone. If it works, let me know as well :)\nWhat can be done differently Instead of copying the bootstrap loader to the chosen place in RAM, we can copy the whole shellcode. However, it shouldn\u0026rsquo;t contain any zero bytes, so it should be prepared for that at first.\nThe very first thing in our shellcode is a call with no offset, which is compiled to e8 00 00 00 00. It\u0026rsquo;s possible to replace this code with the one that doesn\u0026rsquo;t contain zero bytes, and that would be a good solution. However, there are many other \u0026ldquo;holes\u0026rdquo; in the compiled shellcode, and working them around one-by-one would require a lot of additional labor. What we can do instead is find a byte that never occurs in the rest of the compiled shellcode, XOR this part of the shellcode with this byte (which will effectively change all bytes in the binary to a non-zero ones), and write a small loader what will XOR the whole shellcode back before executing. This is precisely what the Splinter Cell exploit does:\nAfter that, the exploit is just copied as part of the string to the chosen place in RAM and executed. Theoretically, this approach should be more reliable since we control where to copy the shellcode. So if the exploit doesn\u0026rsquo;t work on some of the consoles, there\u0026rsquo;s a clear idea on how to fix it.\nLinks GitHub repo with the compiled exploit, source files, and the decryptors for the 007 and Splinter Cell exploits Credits Big thanks to:\nDerf, dj0wns and Thrimbor for their help with the project; XboxDev community in general for being an amazing place. Further reading \u0026ldquo;17 Mistakes Microsoft Made in the Xbox Security System\u0026rdquo; by Michael Steil; Technical Analysis of 007: Agent Under Fire save game hack ","date":"2022-10-03","permalink":"https://agarmash.com/posts/xbox-frogger-beyond-exploit/","tags":["Xbox","Exploitation"],"title":"Exploiting Xbox Game Frogger Beyond to Execute Arbitrary Unsigned Code"},{"content":"In this post, we\u0026rsquo;re going to dissect a very simple challenge from Hack the Box, \u0026ldquo;Behind the Scenes\u0026rdquo;. We\u0026rsquo;ll also look at how to work with Unix signals and how to skip illegal instructions in executables. Buckle up!\nCracking the challenge First of all, let\u0026rsquo;s try running the challenge executable.\nThe program expects a single argument with a password. Neat. Running strings over the executable haven\u0026rsquo;t yielded anything interesting, so let\u0026rsquo;s look at its internals with Ghidra.\nLooking at the main function, we can see some Unix signals trickery at the beginning, and the endless loop with the invalidInstructionException(); in the end.\nLet\u0026rsquo;s begin with the latter. While selecting the invalidInstructionException(); instruction in the decompilation, Ghidra highlights the following assembly instruction:\n001012e6\t0f 0b\tUD2 Referring to Intel® 64 and IA-32 Architectures Software Developer Manual, Vol. 2B, UD2 \u0026ldquo;generates an invalid opcode exception. This instruction is provided for software testing to explicitly generate an invalid opcode exception. The opcodes for this instruction are reserved for this purpose.\u0026rdquo;\nGhidra stops disassembling the file after the first occurrence of UD2. It makes total sense, by default the whole program will be terminated due to receiving a SIGILL Unix signal. However, there\u0026rsquo;s clearly more code after that instruction:\nSo, first of all, let\u0026rsquo;s select the rest of the code that hasn\u0026rsquo;t been disassembled and disassemble it by pressing \u0026ldquo;D\u0026rdquo;. As we can see, it\u0026rsquo;s indeed the executable code:\nNext, let\u0026rsquo;s replace all occurrences of the UD2 instruction with a NOP (there are a few dozens of them scattered across the main function). After doing so, we can immediately see that there are 4 strcmps comparing the user input with string constants. And the flag seems to be a concatenation of these constants:\nBy inputting the concatenated value into the program, we can verify that it\u0026rsquo;s the correct flag. Easy, huh?\nBut how does it work? That\u0026rsquo;s a good question, let\u0026rsquo;s figure it out.\nAs I\u0026rsquo;ve mentioned earlier, the operating system sends a SIGILL signal to the program trying to execute an illegal instruction. But can we skip the illegal instruction and continue the execution? The answer is yes, and that\u0026rsquo;s what the program does by registering a custom signal handler.\nInstalling a signal handler Let\u0026rsquo;s take a look at the decompiled fragment of the main once again:\nLet\u0026rsquo;s break it down:\nLine 6, a property of type sigaction is defined. For convenience, I renamed it to sa; Line 10, sa gets filled with zeroes to clear the allocated memory. We can make an educated guess that initially, it looked like memset(\u0026amp;sa, 0, sizeof(struct sigaction)), but the compiler was able to replace the sizeof call with a constant value; Line 11, sa.sa_mask is cleared out by calling the sigemptyset function; Line 12, a pointer to the local signal handler function segill_sigaction is assigned to the sa.sa_sigaction (named by Ghidra as sa.__sigaction_handler); Line 13, the value of SA_SIGINFO flag is assigned to the sa.sa_flags (#define SA_SIGINFO 0x00000004 in signal.h); Line 14, the constructed sa structure is assigned as a handler for a SIGILL signal (#define SIGILL 4 in signal.h) by calling the sigaction function (yes, the structure and the function are named identically). Handling the received signal The next piece of the puzzle is the signal handler function, segill_sigaction in our case.\nThe signature of the handler function is void handler(int sig, siginfo_t *info, void *ucontext). As sigaction(2) page states, these three arguments are as follows:\nint sig: The number of the signal that caused invocation of the handler; siginfo_t *info: A pointer to a siginfo_t, which is a structure containing further information about the signal; void *ucontext: This is a pointer to a ucontext_t structure, cast to void *. The structure pointed to by this field contains signal context information that was saved on the user-space stack by the kernel. Page sigaction(3p) also states that new applications should explicitly cast the third argument of the signal handling function to ucontext_t *.\nLet\u0026rsquo;s retype the 3rd parameter and take a look at the decompilation:\nFirst of all, let\u0026rsquo;s take a look at the ucontext_t structure contents. As The GNU C Library Reference Manual states, it should include at least the following fields:\nucontext_t *uc_link: This is a pointer to the next context structure which is used if the context described in the current structure returns; sigset_t uc_sigmask: Set of signals which are blocked when this context is used; stack_t uc_stack: Stack used for this context. The value need not be (and normally is not) the stack pointer; mcontext_t uc_mcontext: This element contains the actual state of the process. The mcontext_t type is also defined in this header but the definition should be treated as opaque. Any use of knowledge of the type makes applications less portable. Aha, we\u0026rsquo;re getting closer. Let\u0026rsquo;s take a look at the excerpt from the glibc sources for the x86-64 architecture containing the mcontext_t definition and some of its nested data types:\n/* Context to describe the whole processor state. */ typedef struct { gregset_t __ctx(gregs); fpregset_t __ctx(fpregs); __extension__ unsigned long long __reserved1 [8]; } mcontext_t; /* Container for all general registers. */ typedef greg_t gregset_t[__NGREG]; /* Number of each register in the `gregset_t' array. */ enum { REG_R8 = 0, # define REG_R8\tREG_R8 REG_R9, # define REG_R9\tREG_R9 REG_R10, # define REG_R10\tREG_R10 REG_R11, # define REG_R11\tREG_R11 REG_R12, # define REG_R12\tREG_R12 REG_R13, # define REG_R13\tREG_R13 REG_R14, # define REG_R14\tREG_R14 REG_R15, # define REG_R15\tREG_R15 REG_RDI, # define REG_RDI\tREG_RDI REG_RSI, # define REG_RSI\tREG_RSI REG_RBP, # define REG_RBP\tREG_RBP REG_RBX, # define REG_RBX\tREG_RBX REG_RDX, # define REG_RDX\tREG_RDX REG_RAX, # define REG_RAX\tREG_RAX REG_RCX, # define REG_RCX\tREG_RCX REG_RSP, # define REG_RSP\tREG_RSP REG_RIP, # define REG_RIP\tREG_RIP REG_EFL, # define REG_EFL\tREG_EFL REG_CSGSFS, # define REG_CSGSFS\tREG_CSGSFS REG_ERR, # define REG_ERR\tREG_ERR REG_TRAPNO, # define REG_TRAPNO\tREG_TRAPNO REG_OLDMASK, # define REG_OLDMASK\tREG_OLDMASK REG_CR2 # define REG_CR2\tREG_CR2 }; As we can see, the field gregs contains all the saved CPU registers.\nAt this point, let\u0026rsquo;s refer back to sigaction(3p) that states that \u0026ldquo;when the signal handler returns, the receiving thread resumes execution at the point it was interrupted unless the signal handler makes other arrangements\u0026rdquo;. In our case, we deliberately want to resume the execution after skipping the invalid instruction. Since the UD2 operation is 2 bytes long, we can achieve that by incrementing the RIP register by 2.\nIn C, it would look like this:\nucontext-\u0026gt;uc_mcontext.gregs[REG_RIP] += 2; Important note: this solution is quite hacky and tied up to run strictly on x86-64 POSIX-compliant systems. Don\u0026rsquo;t do this in any production code.\nThe only possible exception is if you deliberately trying to do some bizarre obfuscation, this can be one of your tools - since you have the access to all the saved context, it\u0026rsquo;s possible to change the values of the general-purpose registers, jump to another address by modifying the instruction pointer, and do another weird stuff (:\nCompare it with what the Ghidra decompiled. Looks quite similar, isn\u0026rsquo;t it? :)\nThe only difference is that Ghidra wasn\u0026rsquo;t able to figure out the name of the register and just provided its index in the array, 0x10. We can manually verify that it\u0026rsquo;s the correct index of the REG_RIP. Alternatively, we can print the index of REG_RIP by running this snippet of code, which in turn prints 0x10:\n#define __USE_GNU #define _GNU_SOURCE #include \u0026lt;stddef.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;ucontext.h\u0026gt; void main() { printf(\u0026quot;0x%x\\n\u0026quot;, REG_RIP); } Another way of doing that is to find the offset in the whole ucontext_t structure. Imagine that we only have the assembly listing of the function, which looks like this:\nAfter some argument shuffling, the address of the ucontext gets stored in the local_ucontext variable. Its value at the offset 0xa8 is loaded into the RAX, incremented by 2, and written back into the structure.\nFor the reference, function decompilation looks like this:\nBy making an educated guess we assume that the function increments the RIP register. We can find it\u0026rsquo;s offset in the structure by running the following snippet of code:\n#define __USE_GNU #define _GNU_SOURCE #include \u0026lt;stddef.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;ucontext.h\u0026gt; void main() { size_t rip_offset = offsetof(ucontext_t, uc_mcontext.gregs[REG_RIP]); printf(\u0026quot;0x%x\\n\u0026quot;, rip_offset); } It prints 0xa8, which matches the offset in both the assembly listing and the decompilation.\nCombining it all together Now let\u0026rsquo;s combine all the pieces of the puzzle together. Here\u0026rsquo;s a simple program which conceptually works the same as the challenge binary:\n#include \u0026lt;stdio.h\u0026gt; #define __USE_GNU #include \u0026lt;signal.h\u0026gt; #include \u0026lt;string.h\u0026gt; void sighandler (int signo, siginfo_t *info, void *context) { ucontext_t *uc = (ucontext_t *)context; int instruction_length = 2; // The length of the \u0026quot;instruction\u0026quot; to skip uc-\u0026gt;uc_mcontext.gregs[REG_RIP] += instruction_length; } void main() { struct sigaction sa; memset(\u0026amp;sa, 0, sizeof(struct sigaction)); sigemptyset(\u0026amp;sa.sa_mask); sa.sa_flags = SA_SIGINFO; sa.sa_sigaction = sighandler; sigaction(SIGILL, \u0026amp;sa, NULL); printf(\u0026quot;%s\u0026quot;, \u0026quot;Reachable\\n\u0026quot;); asm(\u0026quot;ud2\u0026quot;); // Adding an illegal opcode printf(\u0026quot;%s\u0026quot;, \u0026quot;Unreachable\\n\u0026quot;); } All in all, the resulting code is quite similar to the accepted answer to this question on Stack Overflow.\nAfter compiling and executing it prints the following:\nComparing the binaries In conclusion, let\u0026rsquo;s compare the decompilation of our recreated binary (on the left, compiled with gcc (GCC) 12.1.0) and the one from the challenge (on the right):\nIt\u0026rsquo;s surprising how similar they are, and how close the decompilation is to the source code!\nThat\u0026rsquo;s it for today. Thanks for reading, and happy hacking!\nFurther reading Linux Signals for the Application Programmer, Linux Journal ","date":"2022-06-13","permalink":"https://agarmash.com/posts/htb-behindthescenes-writeup/","tags":["HackTheBox","CTF","Writeup"],"title":"Hack the Box \"Behind the Scenes\" Writeup, or How to Skip Illegal Instructions in Executables"},{"content":" Originally posted in Akvelon Blog\nWhile working on one of the apps, we faced the need to trim the recorded audio files. We were working with 32-bit float WAV files, and we had the following requirements:\nthe output file should have the exact same format as the input file; no processing should be applied to the audio data, audio samples should be copied as-is; there should be an ability to add silence to the output file. My first guess was to use AVAssetExportSession, but it has limited options for exporting the audio, and it’s not possible to be sure what it does with the audio under the hood. A no-go.\nSecondly, I took a look at the requirements again. \u0026ldquo;Audio samples should be copied as-is\u0026rdquo;. That was exactly what we needed - to open the input file for reading, the output one for writing, calculate the range of audio samples to copy, and perform the actual copying. Fortunately, it was completely possible with AVAudioFile - it can be read into AVAudioPCMBuffer and written from one\u0026rsquo;s contents.\nA few words regarding the output format While working on implementing this functionality, I was sure that AVFoundation converts the data to the set format of the output file on the fly. However, as later turned out, the header of the output file matched the set format, but the actual audio data had the format of the internal processing with AVFoundation (32-bit float WAV).\nIt’s possible to use AVAudioConverter to convert the audio to the desired format, but this is out of the scope of this article.\nAlso, keep in mind that multiple conversions from lossy to lossy format (like MP3 or AAC) will degrade the audio quality. Theoretically, it’s possible to copy the lossy audio data directly, like mp3DirectCut does, but this is also a thing to figure out yourself.\nPreparation First, we have to open the input file for reading, get some information about it, and open the output file for writing.\nOpening the file for reading is simple:\nlet inputFile: AVAudioFile = try! AVAudioFile(forReading: inputFileURL) Note: All the force unwraps, force tries, and fatalError()’s were added to keep the code examples concise. In the real app, all these things should be handled properly.\nAfter doing so, we can take a look at 2 important properties of the opened file:\nfileFormat: AVAudioFormat - the format of the audio file itself; processingFormat: AVAudioFormat - the format that AVFoundation will use to process the audio. As I mentioned earlier, the format of our files matched the internal processing format of AVFoundation. That’s why it was possible to use fileFormat for allocating audio buffers and exporting audio data. When I tried an input file with even a slightly different format, everything went down in flames. In the course of the article, I’ll be using processingFormat as the correct one for manipulating audio data.\nFor our task, we’re going to use the following properties of the input file:\nprocessingFormat: AVAudioFormat - see above; processingFormat.sampleRate: Double - the sample rate of the audio file; length: Int64 - the length of the audio file in samples. Note: In case digital audio is Greek to you, and you have no clue what the sample rate is, here’s a great article describing the basics.\nLater, we\u0026rsquo;re going to need the processing format, its sampling rate, and duration in seconds. Let\u0026rsquo;s define them as the new properties for convenience:\nlet processingFormat = inputFile.processingFormat let sampleRate = Int(processingFormat.sampleRate) let duration = Double(inputFile.length) / Double(sampleRate) Note: In this article, we’re going to cast a lot of values to the different types. At some point, it will become a total mishmash.\nThen we can open the output file for writing, setting it up with the processing format:\nlet outputFile: AVAudioFile = try! AVAudioFile( forWriting: outputFileURL, settings: processingFormat.settings, commonFormat: processingFormat.commonFormat, interleaved: processingFormat.isInterleaved) Also, looking a bit ahead, let\u0026rsquo;s define the default buffer size that we\u0026rsquo;re going to use. In my experience, buffer with the size of the sample rate (e.g. storing one second of the audio) works just fine:\nlet defaultBufferSize = sampleRate Finally, we are prepared for the action. It\u0026rsquo;s time to copy some audio data!\nCopying the arbitrary segment of the audio file We\u0026rsquo;ll start with the case where we have to copy a segment of the audio file. Let\u0026rsquo;s define the start and the end time, and check that they are valid:\nlet startTime: Double = 1.0 let endTime: Double = 2.0 guard startTime \u0026lt; endTime, startTime \u0026gt;= 0, endTime \u0026lt;= duration else { fatalError() } Then we have to figure out the offset of the segment and its duration in samples:\nlet offset = Int64(Double(sampleRate) * startTime) var samplesToCopy = Int(Double(sampleRate) * (endTime - startTime)) Now the interesting part begins. AVAudioFile has framePosition property - \u0026ldquo;the position in the file at which the next read or write operation will occur\u0026rdquo; as the documentation says. It gets automatically advanced on reading or writing operation by the number of frames read or written respectively. Fortunately for us, it can also be set manually to perform a seek before a read or write. As you might have guessed, this is what we computed the offset for:\ninputFile.framePosition = offset Finally, it\u0026rsquo;s time to copy the audio data. Let\u0026rsquo;s take a look at the complete code snippet and break it apart right after:\n// 1 while samplesToCopy \u0026gt; 0 { // 2 let bufferCapacity = min(samplesToCopy, defaultBufferSize) // 3 let buffer = AVAudioPCMBuffer( pcmFormat: processingFormat, frameCapacity: AVAudioFrameCount(bufferCapacity))! // 4 try! inputFile.read(into: buffer) try! outputFile.write(from: buffer) // 5 samplesToCopy -= Int(buffer.frameLength) } Repeat the process until the whole number of samples is copied; Define how many samples to copy during the iteration. At some point, the remaining number of samples to copy will be less than a default buffer size, so this should be used as a buffer size instead; Instantiate the buffer with the proper audio format and the determined size; Read the input file into the buffer and write it into the output file. Important note: the documentation says that the system will try to fill the buffer to its capacity, but it\u0026rsquo;s not guaranteed. That\u0026rsquo;s why we\u0026rsquo;re repeating the loop until the desired number of samples is copied rather than copying a precalculated number of the buffers; Decrease the sample counter by the number of actually copied samples. And the last step - to write the complete output file into the disk, the outputFile has to be deinitialized, which can be achieved by removing all its strong references (if you only referred to it from the property declared inside a method, then it will happen when the method returns). Not as scary as it could be, right?\nCopying the last part of the audio file Now let\u0026rsquo;s look at how we can cut some corners if we only need to copy the \u0026ldquo;tail\u0026rdquo; of the audio file with the desired length.\nThis time we\u0026rsquo;ll define a segment duration and check its validity:\nlet segmentDuration: Double = 4.0 guard segmentDuration \u0026lt;= duration else { fatalError() } Offset calculation is also pretty straight-forward:\nlet offset = inputFile.length - Int64(Double(sampleRate) * segmentDuration) inputFile.framePosition = offset And here lies the main difference - instead of calculating how many samples should be copied, we just perform the copying until we reach the end of the input file:\nwhile inputFile.framePosition \u0026lt; inputFile.length { let buffer = AVAudioPCMBuffer( pcmFormat: processingFormat, frameCapacity: AVAudioFrameCount(defaultBufferSize))! try! inputFile.read(into: buffer) try! outputFile.write(from: buffer) } This is one of the practical examples of the situation when the buffer may not be filled completely if there\u0026rsquo;re not enough samples left in the input file.\nThe rest is identical - deinit the output file and you are free to go!\nAdding silence to the output file Now let\u0026rsquo;s add some silence to the output file, for example, to round up its duration. Obviously, we need a buffer which we will later write into the output file. Let\u0026rsquo;s begin with obtaining one:\nlet silenceDuration: Double = 0.7 let silenceLength = silenceDuration * Double(sampleRate) let buffer = AVAudioPCMBuffer( pcmFormat: processingFormat, frameCapacity: AVAudioFrameCount(silenceLength))! Since in our case we had to add no more than a second of silence, we used a single buffer, but if you consider adding hours of silence, it\u0026rsquo;s better to work with small buffers in a loop similar to what we did earlier.\nNow we have an empty buffer, and it has to be filled with silence somehow. The first thing that interests us is the buffer\u0026rsquo;s frameCount property, which represents the number of valid audio frames in the buffer. Its value can be changed manually, so to make the buffer look like it\u0026rsquo;s filled up with data, we can do the following:\nbuffer.frameLength = buffer.frameCapacity If you try to write this buffer into the file now, it may work, especially if you\u0026rsquo;re testing it in a debug build. However, there\u0026rsquo;s no guarantee that the buffer\u0026rsquo;s memory will be zeroed out in the release build, so in the wild, you can get anything but silence.\nTherefore, we need to fill the buffer with zeros manually. We\u0026rsquo;ll go a dangerous way, using the old infamous memset. Some smart people call it the most troublesome function in history, so it wouldn’t hurt to double-check that everything is implemented correctly. This approach was described by theanalogkid on the Apple Developer Forums with the sample code written in Objective-C. Here’s how the implementation in Swift code looks:\n// 1 let bytesPerFrame = Int(processingFormat.streamDescription.pointee.mBytesPerFrame) // 2 guard let channelDataPointer = buffer.floatChannelData else { fatalError() } // 3 for channel in 0..\u0026lt;Int(processingFormat.channelCount) { // 4 memset(channelDataPointer[channel], 0, silenceLenght * bytesPerFrame) } Here\u0026rsquo;s what we do:\nGetting the size of a single audio frame in bytes; Getting a pointer to the buffer with the audio data. Since we\u0026rsquo;re working with floating-point audio, the buffer we\u0026rsquo;re looking for is floatChannelData. All the 3 buffer referring properties (float, int16, and int32) are optional, so if you’re unsure about the audio data format, it’s possible to optional chain them like buffer.floatChannelData ?? buffer.int16ChannelData ?? buffer.int32ChannelData; Iterating through the indexes of the audio channels; For each audio channel, writing the exact number of zeroed bytes to fill all the audio frames. Now the buffer can be safely written to the file, and that\u0026rsquo;s it. We just added some silence to the audio file. As always, don’t forget to close the output file when you’re done writing into it.\nConclusion As you can see, it’s not that hard to do the basic audio file trimming without using any 3rd-party libraries. The described techniques can be applied further, for example, to compose pieces of the audio file in arbitrary order or to concatenate multiple audio files. The only drawback is the need to convert the audio to the desired output format manually.\n","date":"2021-12-26","permalink":"https://agarmash.com/posts/avfoundation-audio-trimming/","tags":["Swift","AVFoundation"],"title":"Trimming Audio Files and Adding Silence with AVFoundation in Swift"},{"content":"A story about reverse engineering and way too smart FTP client\nSome time ago, I decided to swap HDD in my Original Xbox. It already has been upgraded with a 40 Gb IDE drive, but I had a spare 160 Gb SATA drive laying around and wanted to have some more storage in the system. I bought a SATA to IDE converter, swapped the drives, installed the system software, and transferred all the content back. To my utmost disappointment, savefiles for some games were corrupted. One of them was Black, where I had a decent amount of played hours. I did some basic troubleshooting but wasn\u0026rsquo;t able to find the source of the problem. At that moment it was obvious to me that the problem lay in the new hard drive.\nIf you\u0026rsquo;re here to know how to patch a game\u0026rsquo;s binary, jump straight to the Patching the binary yourself.\nOG Xbox Savefiles 101 To prevent any tampering, all the game developers were obliged to add a digital signature to the savefiles of their games.\nAdditionally, developers were able to make savefiles \u0026ldquo;non-roamable\u0026rdquo;, i.e. lock them to the particular console they were created on. For achieving that, Xbox has a so-called \u0026ldquo;XboxHDKey\u0026rdquo; - a per-console value stored in the EEPROM intended specifically for the content locking. The list of such games is well known and maintained by the community. However, Black wasn\u0026rsquo;t on the list. (While writing this post, I was able to find an extended list, and even find a resigner specifically for Black. Funny enough, it wouldn\u0026rsquo;t help me with the issue I had in the first place.)\nIf you want to dive deeper into the topic, those pages are for you:\nA thread in comments on Reddit by feudalnate_ \u0026ldquo;Xbox save resigning – a technical overview\u0026rdquo; by gothi So, at that moment I was convinced that some additional checks were implemented in the game. I thought that probably HDD\u0026rsquo;s model and serial number were also used for the signature generating. There was only one way to know for sure.\nReverse engineering and patching game\u0026rsquo;s executable I decided to analyze the executable binary with Ghidra. To be able to do so, I additionally grabbed ghidra-xbe, an extension for the Ghidra to support loading Xbox Executable Format (XBE) files, and xbox-includes, a set of GPL-sourced Xbox headers. Loading and analyzing the game\u0026rsquo;s executable was straightforward, but importing headers had a quirk. For some reason, Ghidra wasn\u0026rsquo;t happy with the HANDLE type, but renaming it to something different like HANDLE_MY solved the problem.\nNow we are fully prepared to begin digging. Searching for the word \u0026ldquo;signature\u0026rdquo; in the program text immediately yielded some promising results:\nA lot of recovered (or maybe unstripped?) symbols, the most interesting of which is \u0026ldquo;XCalculateSignatureBegin\u0026rdquo;. Quick googling gave me the following function definitions from the XAPI:\nHANDLE XCalculateSignatureBegin(DWORD dwFlags); DWORD XCalculateSignatureUpdate(HANDLE hCalcSig, BYTE* pbData, ULONG cbData); DWORD XCalculateSignatureEnd(HANDLE hCalcSig, BYTE* pbSignature); By making an educated guess, we can assume that 1st function creates a handle object set up with some flags, 2nd one takes the binary data and its size to calculate the signature for, and the last one writes the signature into the provided address. The flags are also conveniently listed on the page mentioned above, but we\u0026rsquo;ll get to them later.\nNow we can complete the function signature and take a look a look at its callers. There are 2 of them, and for the reader\u0026rsquo;s convenience, we\u0026rsquo;ll start with the 2nd one. This is how it looks after decompilation:\nThe obtained handler is checked not to be -1, and after that 2 functions are called, whose parameters are suspiciously similar to XCalculateSignatureUpdate and XCalculateSignatureEnd. After completing their signatures the decompiled code of the function started to look like this:\nNow let\u0026rsquo;s take a close look. The ~Update function takes EAX as the pointer to the source data and 0x17ec as the data length. The ~End function takes EAX advanced by the same 0x17ec bytes. Most of the games stored the signature at the end of the savefile, so we can conclude that this function is responsible for adding the signature to the savefile while saving the game. You can be creative and replace this function implementation to add some custom data instead of the signature. Does anyone want to place an ad to the savefile of the 15 years old game where nobody will ever see it? No? Okay, let\u0026rsquo;s move forward then.\nNow we\u0026rsquo;ll take a look at the 1st of 2 callers. Its decompiled code looks like this:\nHere, the ~Update function gets called identically, but the ~End function takes a pointer to the local 20 bytes long variable as its second parameter. Perfect! The rest of decompiled code looks like total gibberish, so let\u0026rsquo;s take a look at the assembly listing:\nAfter calling the ~End function, pointers to the signature from the savefile and calculated signature get loaded to the EDI and ECI respectively, signature length gets loaded to ECX, and they got compared by the following instruction:\n001f2dfd f3 a6 CMPSB.REPE ES:EDI,ESI If the comparison is successful, i.e. the difference between signatures is 0, the following conditional jump gets performed:\n001f2e01 74 05 JZ LAB_001f2e08 The rest of the code is some compiler optimized preparation of the return value, which is not interesting. What\u0026rsquo;s interesting is to skip the code that gets executed if the check was not successful. The most straightforward thing to do is to replace the conditional jump with an unconditional one. It can be achieved by changing the instruction from JZ (opcode 74) to JMP (opcode EB). After doing so, saving the patched binary, and transferring it to the directory with the game backup on the Xbox via FTP, I was ready for testing. Unfortunately, an unexpected discovery has happened.\nA terrible mistake With patched binary, I also transferred my old savefile to the console. And I noticed something. The savefile size on my computer was 6144 bytes, while on the console it was a few bytes larger, something like 6147 bytes. I took a few seconds to digest it and then realized that I made a terrible mistake. As I figured out, FileZilla, an FTP client that I used automatically corrects line breaks while transferring text files between Windows and Unix systems, and by default, it treats files without an extension as text files. So, while I was thinking about some sophisticated anti-tampering system in the game, my FTP client was just corrupting the files.\nAfter properly configuring FileZilla, I copied the savefile to the console, verified its size, launched the game from the vanilla executable, and it loaded the savefile normally. Just to verify whether my patch is working, I changed a few bytes in the savefile signature, copied it to the console, launched the game from the patched binary, and it also loaded the savefile normally! Yay!\nIt could be the end of the story, but in the process, I found something else.\nSigning flags and non-roamable saves Remember the flag that is passed into the ~Begin function? If we look back at the decompiled code, the 1 is passed in both function calls:\nhCalcSig = XAPILIB::XCalculateSignatureBegin(1); What does the 1 mean? Fortunately, the same Reddit page mentioned above gives us the answer:\nDWORD XCALCSIG_FLAG_NON_ROAMABLE = 0x00000001; So, this precisely tells us that the game incorporates non-roamable savefiles. Their signatures are tied to a particular console with mentioned above XboxHDKey and can\u0026rsquo;t be transferred to another console. But since we disabled signature checking, they now can be!\nSo, to recap: this patch allows you to freely move the savefiles between consoles without any additional actions like resigning. And this is some great news!\nPatching the binary yourself For obvious reasons, I can\u0026rsquo;t distribute the patched binary. However, I can show you how to patch one. During my research, I was using default.xbe file marked as region-free (game region value in the xbe certificate is 7, which means all regions) with md5 hash d21025a12520a74a2edd6c86fef9b57e. The patching is simple - open the file with a hex editor, find a byte 74 at the offset 0x1E2E01, and replace it with EB. That\u0026rsquo;s it.\nIf there\u0026rsquo;s something different at the aforementioned offset, you can also try looking for the following byte sequence 74240833 C0F3A65F 5E74051B C083D8FF and replace its 10th byte as described above.\nTransferring savefiles without modifying the game If you don\u0026rsquo;t have an option to use the patched binary (for example, you prefer to run games from the original discs), it\u0026rsquo;s also possible to resign the savefile. You can find a standalone resigner for Windows, its source code, and additional config for XSavSig in the feudalnate\u0026rsquo;s GitHub repository.\nWrapping up So, what do I think about all this in the end? Was all this needed from the perspective of just playing video games? Not at all. Did I learn a lot about reverse engineering in the process? Absolutely yes! And I really enjoyed the process, it was quite interesting to dive deep and figure out how things work. And in the process, I somewhat contributed to video games preservation, which is also amazing!\nNow I can confidently say that the Original Xbox helped me learn some new skills and has a special place in my life!\n","date":"2021-12-09","permalink":"https://agarmash.com/posts/xbox-black-reverse-engineering/","tags":["Xbox","Reverse Engineering"],"title":"Patching Xbox Game Black to Disable Savefile Signature Checking"},{"content":"While implementing audio playback with AVAudioPlayer, you may need to display the playback progress with UIProgressView, or even to synchronize the state of the player with UISlider. AVAudioPlayer doesn\u0026rsquo;t have any functionality to get periodically notified about the current playback position. However, it has 2 aptly named properties that represent the time of the current playback position and the duration of the audio file: currentTime and duration respectively.\nBad approach - using Timer The first thing that comes to mind is to set up a Timer to periodically calculate the playback progress and to update the UI. Picking the right update interval also seems as easy as getting the refresh rate of the device\u0026rsquo;s screen and figuring out the duration of a single frame: 1 / Double(UIScreen.main.maximumFramesPerSecond). But here I have to stop you since this approach has a flaw - the timer isn\u0026rsquo;t synchronized with screen refreshing, so there\u0026rsquo;s no guarantee that each invocation of the timer will correspond with the new frame being drawn on the screen. This may cause an unpleasant jitter in the UI, and this phenomenon is covered in great detail in this article. Fortunately, there\u0026rsquo;s a more suitable alternative, and as you\u0026rsquo;ve guessed, I\u0026rsquo;m talking about CADisplayLink.\nBetter approach - using CADisplayLink CADisplayLink is a timer object that is synchronized with the refresh rate of the display. To learn more about it, check the documenation and this detailed article. Instead, let\u0026rsquo;s see how it can be applied to the task.\nImplementing UI updating At first, let\u0026rsquo;s implement updating of the UI components using the display link:\nclass AudioPlayerViewController: UIViewController { // 1 @IBOutlet weak var slider: UISlider! // or @IBOutlet weak var progressView: UIProgressView! // 2 var player: AVAudioPlayer // 3 lazy var displayLink: CADisplayLink = CADisplayLink(target: self, selector: #selector(updatePlaybackStatus)) // 4 func startUpdatingPlaybackStatus() { displayLink.add(to: .main, forMode: .common) } func stopUpdatingPlaybackStatus() { displayLink.invalidate() } // 5 @objc func updatePlaybackStatus() { let playbackProgress = Float(player.currentTime / player.duration) slider.setValue(playbackProgress, animated: true) // or progressView.setProgress(playbackProgress, animated: true) } } Additional comments to the code:\nAn outlet to the UI component you want to update. It can be UISlider, UIProgressView, or some custom view that shows the progress. If you stick with UISlider, make sure that its min and max values are set to 0 and 1 respectively. The same applies to custom views as well; A reference to the AVAudioPlayer, just for clarity; A property storing an instance of CADisplayLink. Since we use self as the target, the initialization of CADisplayLink should be done after initializing the parent class to be able to correctly reference it. For that purpose I made it lazy; Methods that start and stop updating the UI. You should call them when the playback status changes. The method that gets called during screen refresh, the logic for updating the UI is stored here. That\u0026rsquo;s all that has to be done to update the UI component. However, if you want to use a slider for seeking through audio, some more things have to be done.\nAdding playback control with slider I\u0026rsquo;m going to replicate the behavior of the Music.app, where the audio position changes only at the moment of releasing the slider. Here\u0026rsquo;s what has to be added:\n// 1 @IBOutlet weak var slider: UISlider! { didSet { slider.addTarget(self, action: #selector(didBeginDraggingSlider), for: .touchDown) slider.addTarget(self, action: #selector(didEndDraggingSlider), for: .valueChanged) slider.isContinuous = false } } // 2 @objc func didBeginDraggingSlider() { displayLink.isPaused = true } @objc func didEndDraggingSlider() { let newPosition = player.duration * Double(slider.value) player.currentTime = newPosition displayLink.isPaused = false } Add actions for slider\u0026rsquo;s touchDown and valueChanged events to get notified when the user begins and ends dragging the slider respectively. Also, set one\u0026rsquo;s isContinuous property to false, so the valueChanged event is reported only when the user releases the slider. This setup can also be done with Interface Builder and IBActions; Add the methods for handling slider\u0026rsquo;s events and implement fairly straightforward logic - pause display link when the user begins dragging the slider, so its value isn\u0026rsquo;t updated during user interaction; seek the audio to the selected position and resume display link when the user released the slider. That\u0026rsquo;s all that has to be done to make the user experience of your app a bit sleeker!\n","date":"2021-03-10","permalink":"https://agarmash.com/posts/avaudioplayer-playback-progress/","tags":["Swift","AVAudioPlayer","UISlider","UIProgressView"],"title":"Using UISlider or UIProgressView to Display and Control the Playback Progress of AVAudioPlayer"},{"content":"I\u0026rsquo;ve accomplished this little project back in 2016 when I had two Xbox 360 wireless controllers and a huge desire to use them with a PC. To do so, you have to have a wireless receiver, and there were 2 mainstream options on the market:\na genuine one - the best option, but costs around $60; an unofficial replica - can be found for $10-15, but reliability and driver support were quite questionable. At that moment, I was short of money to get the first one and didn\u0026rsquo;t want to try luck with the second. Fortunately, if you dive a bit deeper into the topic and doesn\u0026rsquo;t afraid to do some soldering, there\u0026rsquo;s a third option - using an RF module from a broken Xbox 360 (later in the text I\u0026rsquo;ll refer to it just as \u0026ldquo;RF module\u0026rdquo;).\nIf you just want to build your own device, jump straight to the Building the device.\nConnecting the RF module At the moment of working on the project thorough reverse engineering has already been done and documented. The authors figured out that the RF module communicates with Xbox 360 itself via 2 interfaces:\nA proprietary I2C-like protocol, for controlling LEDs and syncing with controllers; USB, for communicating with controllers. The USB connection is quite straightforward - you need to connect the ground and data lines and supply 3.3 volts for the power. Being connected to the PC, the RF module works exactly like the official wireless receiver, the only difference is the PID of the device, but after manually installing the official driver everything works as it should.\nConnecting a control bus is more complicated, but there are a bunch of different options:\nLeave it unconnected. I haven\u0026rsquo;t tried that, but I\u0026rsquo;ve read that the RF module will work fine this way with the controllers that have been previously synced with it. I also read that it\u0026rsquo;s possible to sync a controller by connecting it via Play and Charge Kit to the same computer, but I haven\u0026rsquo;t verified that too. Using a Raspberry Pi. It can be quite handy if you plan to permanently use the RF receiver with Raspberry. It\u0026rsquo;s even possible to display things using the module\u0026rsquo;s LED ring, which can be a nice feature. Using an FT232RL and a program for Windows. I\u0026rsquo;ve checked this one, but it didn\u0026rsquo;t work for me. I tried to attach Saleae logic analyzer to data pins and it seems that my FT232RL\u0026rsquo;s IO wasn\u0026rsquo;t fast enough, seems like I\u0026rsquo;ve got a counterfeit chip. Also, that\u0026rsquo;s way too cumbersome for everyday use. Using an Arduino or a bare microcontroller (also called as MCU) (for example, ATTiny45). As for me, this is the best option since you\u0026rsquo;re getting a self-sufficient device. Bringing AVR to the table I decided to use a microcontroller, and I wanted something that wouldn\u0026rsquo;t be overkill for this task. Fortunately, I had a few ATTiny13 laying around, which is more than enough for the given task. Also, I had a DIY development board based on ATMega16A, which was quite handy for working on the project.\nTo be sure that I implemented the communication protocol correctly and that my module wasn\u0026rsquo;t dead, I wrote the code that received a command via UART and sent it to the RF module. And it worked! Here\u0026rsquo;s a quick demo:\nWhile testing different commands, I decided that the final implementation should allow to sync a new controller and to disable all the connected controllers. For doing so, I connected the power button from the RF module to the microcontroller too and implemented the following logic:\nAfter powering up, the MCU waits for 3.5s to allow the module to boot up properly and sends the \u0026ldquo;LED_INIT\u0026rdquo; command to initialize the LED ring and turn on the green LED in the center; After that, the MCU waits for the button press. On short press, it sends the \u0026ldquo;SYNC\u0026rdquo; command to sync with controllers, on the long press - sends the \u0026ldquo;CTRLR_OFF\u0026rdquo; command to power off all connected controllers and right after that send a bunch of commands to shortly turn on the led ring for the clarity. Initially, I implemented the new logic for ATMega16, and when everything was working as intended, I ported it to ATTiny13, which was a matter of just changing a header file and GPIO ports mapping. When the firmware was ready, it was time to build the final device.\nBuilding the device Here\u0026rsquo;s the list of what you\u0026rsquo;ll need to build the standalone receiver:\nAn RF module itself. You need the one from the first generation of Xbox 360 (so-called Fat model). Also, pay attention to the revision of the module - people discovered that Rev. A modules from Xenon consoles have problems with Windows 8 and have worse connectivity range, while Rev. B and the rest don\u0026rsquo;t have those issues. I\u0026rsquo;ve got a Rev. F module and had zero problems using it with Windows 7 and a wide range of macOS versions. RF modules from Slim and E models aren\u0026rsquo;t suitable - although people figured out how to connect the USB, the control bus seems to be different; AVR microcontroller. The firmware is simple and can be compiled with GCC AVR for any AVR chip with some minor changes. Both source code and the compiled binary for the ATTiny13 are stored in the project repo; A way to provide 3.3v power to the module - I used an 1117-33 LDO voltage regulator with filtering capacitors, but any voltage converter can be applied here; 3 pullup resistors, their optimal value is 10k ohm, but it will work with slightly different values too; A programmer for AVR, a USB connector to your taste, some hooking wire, soldering supplies - the standard stuff. If you haven\u0026rsquo;t worked with AVR or with microcontrollers in general, don\u0026rsquo;t forget that you have to flash the firmware to the MCU. There are plenty of ways to do so, I used FT232RL from the hardware and avrdude from the software side.\nHere\u0026rsquo;s the connection diagram. The RF module\u0026rsquo;s connector is depicted as if you were looking on the front side of it:\nI decided not to bother with making the PCB and connected everything with hooking wires, covering all the dangling components with a heat-shrinking tube. After checking that everything works, I\u0026rsquo;ve zip-tied the receiver to the bunch of cables on the back of my PC and used it this way until moving to another city. I still have the device, and this is how it looks nowadays:\nThat\u0026rsquo;s how my desire to play some games motivated me to build something new!\nLinks Project\u0026rsquo;s repo on GitHub ","date":"2021-02-25","permalink":"https://agarmash.com/posts/xbox-360-controller-receiver/","tags":["Xbox","AVR"],"title":"Building a Wireless Receiver for Xbox 360 Controllers From a Broken Xbox 360 Console"},{"content":"When the whole world was switching to streaming services, I bought an iPod Classic 5.5th generation. An independent device with locally stored music in lossless quality and decent audio codec was, and still is quite appealing for me. And as for me, its design is everlasting, a 14 y/o device still feels great and gets a lot of attention.\nThe only drawback was storage capacity - mine one had a 30 GB HDD, and although it was possible to find a unit with 80 gigs, it also wouldn\u0026rsquo;t be sufficient. Another option was to get a 6/7 generation one with 160 GB HDD, but I wanted to stay with the 5.5th gen unit.\nHardware mod 5th generation of iPods uses 1.8\u0026quot; ZIF HDD, which has an IDE interface with a different shaped connector. There is a number of available replacements:\nSD or CompactFlash adapter with the corresponding memory card — both adapter and large memory card are pricey, but among modding scene, it was the most popular option; 1.8\u0026quot; SSD with ZIF connector — quite a niche thing, which also makes it rather expensive; mSATA SSD with the adapter to ZIF — the least popular option for modding an iPod, but compared to the other options, was the best bang for the buck. The last option was the most compelling for me, so I ordered an mSATA to ZIF adapter based on JM20330 chip (you can find it on eBay searching for \u0026ldquo;zif msata\u0026rdquo;) and a 250 GB Samsung 850 EVO mSATA SSD (its predecessor, 840 EVO had one of the greatest power characteristics, so it was a good choice). Also, I ordered some generic mSATA to regular SATA adapter, which unexpectedly played a great role in the whole project.\nFun fact: 5th generation of iPod has 32 or 64 MB of SDRAM memory (depending on stock HDD capacity), while the ordered SSD has 512 MB of LPDDR3.\nWhen all the parts were delivered, at first I took the spare back cover and the main chassis from another dead iPod and put the mSATA-ZIF adapter between them. As you can see, the clearance was quite tight, there was less than a millimeter for adhesive and isolation.\nAt first, I thought of getting a back cover from a 60/80 GB unit, which is thicker, but I wanted to keep an old thin one. Also, when the SSD was plugged into the adapter, there was a noticeable gap between boards, which was quite a waste of space.\nThen I took a look at the SATA-mSATA adapter and noticed that it had a connector with the same footprint, but was a bit shorter.\nStacking boards together showed that the connectors\u0026rsquo; height difference was very similar to the size of the gap between SSD and mSATA-ZIF adapter.\nDelighted with this coincidence, I took my Rose\u0026rsquo;s metal and hot air soldering station, swapped the connectors, and filed down mounting standoffs to the correct height.\nAfter doing that, the SSD was flush with the mSATA-ZIF adapter board.\nSo I put a piece of isolation between the boards, plugged the SSD into the adapter, and tightened the mounting screws.\nWhen I put the resulting sandwich between spare iPod\u0026rsquo;s case parts, there were almost 2 millimeters of clearance, which was more than enough for securing the new components in place.\nAfter that, I put a layer of isolation to the back cover, added another piece of isolation to the backside of the adaptor board, plugged the ZIF flex cable to the adapter, secured it on the chassis with double-sided tape, and added stripes of packaging material to fill the void space.\nI wanted my iPod to be formatted in FAT32, so I had to use iTunes on Windows PC. After connecting an iPod I tried to restore it with iTunes, but the process was aborted with an error. After some troubleshooting, I figured out that the problem was in the NTFS partition on the SSD, which I created earlier to test the drive. I formatted it externally in FAT32, put back into the iPod and this time was able to restore it with iTunes.\nThe device was working and this could be the end of the story, but I decided to install Rockbox.\nRockbox After the trivial process of installing the custom firmware with Rockbox Utility and rebooting the iPod, I was greeted with the ATA error: -11. At the same time, stock firmware was still working fine. After some googling, I found a thread on Rockbox Forums, where the problem was investigated by the development team and solved by the user beyondwind. He also started a thread on Head-Fi Forums, where he posted some additional information. Unfortunately, at the moment of doing the mod, his website was down. Although it was possible to take a glance at it with help of Wayback Machine, almost all the content was unavailable. All, except the file ipod5g_msata_mod.patch, which undoubtedly was the most important. Also, it was saved on GitHub Gist by one of the users at Rockbox Forums.\nSo, with the patch in my possession, it was possible to build a patched firmware myself. Fortunately, Rockbox Wiki has a detailed guide for building firmware from scratch. The steps for doing so are well described, but I have some notes to make.\n1. Getting the source After cloning the repository, you can already apply the patch. It can be done with a bash command patch -p1 \u0026lt; path_to_file. Important notice about the patch file — the initial version had some changes for the plugin test_disk.c and included it in the regular build. The plugin code was highly modified since then and this part of the patch wasn\u0026rsquo;t applicable anymore, so I made the patch file without the mentioned pieces.\n2. Building a cross-compiler Automatic build works fine, but there are 3 caveats:\nI had a lot of difficulties building it on macOS Catalina. After 2 evenings of figuring out the origins of an endless stream of errors, I fired up a VM with Ubuntu 20.04.1 and was able to build the cross-compiler from one of the first tries. Although, a few years ago, when I built it for the first time, I was able to do it without a headache on macOS Sierra; The master branch sometimes can be broken. If you have difficulties with building, try checking out a bit earlier commit. For example, this one worked fine when I was building on Ubuntu; Make sure that all the dependencies listed on the wiki page are installed — initially, I have issues because of lacking texinfo. 3. Building Rockbox Fortunately, there were no issues here!\nIf everything was done correctly, after copying the freshly built .rockbox directory to the iPod it should just work. Finally, it\u0026rsquo;s time to copy some tunes and listen to them on your modded device!\nAnd also, there\u0026rsquo;s a patched build if you need it but don\u0026rsquo;t want to deal with patching and building.\nAfterword I accomplished this mod in January 2018 and was using the device almost every day since then. Later, I had to replace a battery because the old one dies of old age, but even with the old battery, there were no issues. Battery life is great, access time is instantaneous, and the weight loss is quite perceptible (an old HDD weight is close to the weight of the rest of the iPod). I\u0026rsquo;d recommend doing it to everyone who wants to give a second life to this classic device!\nFiles ipod5g_msata_mod.patch — initial patch file by beyondwind; ipod5g_msata_mod_wo_plugin.patch — modified patch with removed changes for test_disk.c plugin, prefered for using; rockbox_msata_mod.zip — patched build from this commit. ","date":"2020-10-15","permalink":"https://agarmash.com/posts/ipod-classic-ssd/","tags":["iPod","SSD","Rockbox"],"title":"A Journey of Putting an SSD Into an iPod Classic With Rockbox"},{"content":" Initially, I wrote this article for Distillery Tech Blog back in 2018. I decided to copy it here for the further preservation.\nNowadays, everyone values privacy and security. That’s why it wasn’t surprising when, recently, we needed to use an encryption library on one of the projects.\nFor the project in question, the decision was made to use libsignal. Originally developed for Signal Private Messenger, libsignal has a good reputation among security specialists.\nUsing libsignal At the end of July 2018, there were implementations of libsignal in C, Java, and JavaScript. There was also an implementation in Objective-C called SignalProtocolKit, but at that time it had already been deprecated.\nOur goal was to use the library in an iOS app written in Swift. To keep everything up to date, we had to use the one written in C, for which the source code is stored here. Lucky for us, Swift can interact with C code very smoothly, at minimum because some of Apple’s low-level libraries are written in C. The tricky part was to add the library to the project correctly.\nCreating a module.map After a bit of research, I figured out that I could simply add the library’s source code to the project and create a module.map file to specify which headers of the library I wanted to expose (for more detail, check out this blog). libsignal contains lots of header files, but if I want to use it in a regular C project, I only have to include the one called signal_protocol.h. Since signal_protocol.h includes the other headers it depends on, just as every other header file does, we can be sure that all the files are included. Accordingly, I made a module.map file with the following contents:\nmodule SignalProtocol [system] { header “src/signal_protocol.h” export * } Then, I put it into the folder with the library sources, added it to the project, and started to test.\nXcode allowed to import this module and to use some of the library functions, but some of the library components were missing. For example, I was unable to use the signal_context data type which is defined in signal_protocol_internal.h.\nAt that moment it became obvious that Xcode doesn’t properly include nested headers. So I decided to try including all the headers from libsignal in my module.map file. (It’s redundant to put the updated module.map here, as it just includes every *.h file similar to the file above.)\nAfter I did this and tried to build to build the project, I got a lot of errors related to some of the header files from libsignal. When I took a look at them, I realized that there were some header files that were not actual headers. Instead, they store some constant values and are used as follows:\nstatic const fe sqrtm1 = { #include “sqrtm1.h” } ; As of the end of July 2018, the following files were used that way:\nsqrtm1.h ge_sub.h pow225521.h ge_add.h d2.h ge_madd.h ge_msub.h pow22523.h ge_p2_dbl.h d.h base2.h base.h Finally, after excluding these files from my module.map, I was able to build the project and use all the parts of libsignal.\nWas it a victory? A moderate one, I guess. Adding the sources of a third-party library directly to the project didn’t seem quite right, so we decided to wrap libsignal in the Cocoa Touch Framework.\nWrapping It in the Cocoa Touch Framework At first, after all the previous difficulties, I thought this part would be easy. Unfortunately, I was proven wrong the exact moment I opened the Build Settings of our freshly created project framework and couldn’t find the “Swift Compiler — Search Paths” section.\nWhat followed were several attempts to include the libsignal sources in the framework. I will only describe the one that was successful.\nTo wrap a С library in the Cocoa Touch Framework (using the example of libsignal), follow these steps:\n1. Create a New Project Create a new project. For its type, choose “Cocoa Touch Framework.”\n2. Add Source Files Add the source files of the library to the project.\n3. Select Headers to Expose Go to the project file and select your target framework. Open the “Build Phases” tab. Here, in the “Headers” section, all the headers from the library should appear. Decide which ones to expose by dragging them to the “Public” list. In the case of libsignal, I decided to make all the headers public.\nBy the way, here you should have all the *.h files, even those that just store constants.\n4. Import Headers Now, since all the headers have been added to your project, you have to import them into the main header of the framework, which should be called [your framework name].h and placed in the root directory of the framework. Add the following line for every actual header, omitting those that just store constants:\n#import “protocol.h” Note that, since we added all headers to the project file, we only have to use filename without specifying the whole path to the file in the project. It works this way because all of the headers are copied inside the framework bundle, and all paths inside the project become invalid.\nVoilà! You should have a fully functioning framework.\nDo note, however, that at the moment, it has one major disadvantage: It keeps a particular version of libsignal and doesn’t allow you to update it from its GitHub repository. That issue, however, is outside the scope of this article.\n","date":"2020-09-30","permalink":"https://agarmash.com/posts/c-library-in-swift/","tags":["C","Swift"],"title":"How to Integrate a C Library into an iOS App Written in Swift"}]