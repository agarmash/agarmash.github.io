[{"content":"I\u0026rsquo;ve accomplished this little project back in 2016 when I had two Xbox 360 wireless controllers and a huge desire to use them with a PC. To do so, you have to have a wireless receiver, and there were 2 mainstream options on the market:\n a genuine one - the best option, but costs around $60; an unofficial replica - can be found for $10-15, but reliability and driver support were quite questionable.  At that moment, I was short of money to get the first one and didn\u0026rsquo;t want to try luck with the second. Fortunately, if you dive a bit deeper into the topic and doesn\u0026rsquo;t afraid to do some soldering, there\u0026rsquo;s a third option - using an RF module from a broken Xbox 360 (later in the text I\u0026rsquo;ll refer to it just as \u0026ldquo;RF module\u0026rdquo;).\n If you just want to build your own device, jump straight to the Building the device.\n Connecting the RF module At the moment of working on the project thorough reverse engineering has already been done and documented. The authors figured out that the RF module communicates with Xbox 360 itself via 2 interfaces:\n A proprietary I2C-like protocol, for controlling LEDs and syncing with controllers; USB, for communicating with controllers.  The USB connection is quite straightforward - you need to connect the ground and data lines and supply 3.3 volts for the power. Being connected to the PC, the RF module works exactly like the official wireless receiver, the only difference is the PID of the device, but after manually installing the official driver everything works as it should.\nConnecting a control bus is more complicated, but there are a bunch of different options:\n Leave it unconnected. I haven\u0026rsquo;t tried that, but I\u0026rsquo;ve read that the RF module will work fine this way with the controllers that have been previously synced with it. I also read that it\u0026rsquo;s possible to sync a controller by connecting it via Play and Charge Kit to the same computer, but I haven\u0026rsquo;t verified that too. Using a Raspberry Pi. It can be quite handy if you plan to permanently use the RF receiver with Raspberry. It\u0026rsquo;s even possible to display things using the module\u0026rsquo;s LED ring, which can be a nice feature. Using an FT232RL and a program for Windows. I\u0026rsquo;ve checked this one, but it didn\u0026rsquo;t work for me. I tried to attach Saleae logic analyzer to data pins and it seems that my FT232RL\u0026rsquo;s IO wasn\u0026rsquo;t fast enough, seems like I\u0026rsquo;ve got a counterfeit chip. Also, that\u0026rsquo;s way too cumbersome for everyday use. Using an Arduino or a bare microcontroller (also called as MCU) (for example, ATTiny45). As for me, this is the best option since you\u0026rsquo;re getting a self-sufficient device.  Bringing AVR to the table I decided to use a microcontroller, and I wanted something that wouldn\u0026rsquo;t be overkill for this task. Fortunately, I had a few ATTiny13 laying around, which is more than enough for the given task. Also, I had a DIY development board based on ATMega16A, which was quite handy for working on the project.\nTo be sure that I implemented the communication protocol correctly and that my module wasn\u0026rsquo;t dead, I wrote the code that received a command via UART and sent it to the RF module. And it worked! Here\u0026rsquo;s a quick demo:\n  While testing different commands, I decided that the final implementation should allow to sync a new controller and to disable all the connected controllers. For doing so, I connected the power button from the RF module to the microcontroller too and implemented the following logic:\n After powering up, the MCU waits for 3.5s to allow the module to boot up properly and sends the \u0026ldquo;LED_INIT\u0026rdquo; command to initialize the LED ring and turn on the green LED in the center; After that, the MCU waits for the button press. On short press, it sends the \u0026ldquo;SYNC\u0026rdquo; command to sync with controllers, on the long press - sends the \u0026ldquo;CTRLR_OFF\u0026rdquo; command to power off all connected controllers and right after that send a bunch of commands to shortly turn on the led ring for the clarity.  Initially, I implemented the new logic for ATMega16, and when everything was working as intended, I ported it to ATTiny13, which was a matter of just changing a header file and GPIO ports mapping. When the firmware was ready, it was time to build the final device.\nBuilding the device Here\u0026rsquo;s the list of what you\u0026rsquo;ll need to build the standalone receiver:\n An RF module itself. You need the one from the first generation of Xbox 360 (so-called Fat model). Also, pay attention to the revision of the module - people discovered that Rev. A modules from Xenon consoles have problems with Windows 8 and have worse connectivity range, while Rev. B and the rest don\u0026rsquo;t have those issues. I\u0026rsquo;ve got a Rev. F module and had zero problems using it with Windows 7 and a wide range of macOS versions. RF modules from Slim and E models aren\u0026rsquo;t suitable - although people figured out how to connect the USB, the control bus seems to be different; AVR microcontroller. The firmware is simple and can be compiled with GCC AVR for any AVR chip with some minor changes. Both source code and the compiled binary for the ATTiny13 are stored in the project repo; A way to provide 3.3v power to the module - I used an 1117-33 LDO voltage regulator with filtering capacitors, but any voltage converter can be applied here; 3 pullup resistors, their optimal value is 10k ohm, but it will work with slightly different values too; A programmer for AVR, a USB connector to your taste, some hooking wire, soldering supplies - the standard stuff.  If you haven\u0026rsquo;t worked with AVR or with microcontrollers in general, don\u0026rsquo;t forget that you have to flash the firmware to the MCU. There are plenty of ways to do so, I used FT232RL from the hardware and avrdude from the software side.\nHere\u0026rsquo;s the connection diagram. The RF module\u0026rsquo;s connector is depicted as if you were looking on the front side of it:\nI decided not to bother with making the PCB and connected everything with hooking wires, covering all the dangling components with a heat-shrinking tube. After checking that everything works, I\u0026rsquo;ve zip-tied the receiver to the bunch of cables on the back of my PC and used it this way until moving to another city. I still have the device, and this is how it looks nowadays:\nThat\u0026rsquo;s how my desire to play some games motivated me to build something new!\nLinks  Project\u0026rsquo;s repo on GitHub ","date":"2021-02-25","permalink":"https://agarmash.com/posts/xbox-360-controller-receiver/","tags":["xbox","avr"],"title":"Building a Wireless Receiver for Xbox 360 Controllers From a Broken Xbox 360 Console"},{"content":"When the whole world was switching to streaming services, I bought an iPod Classic 5.5th generation. An independent device with locally stored music in lossless quality and decent audio codec was, and still is quite appealing for me. And as for me, its design is everlasting, a 14 y/o device still feels great and gets a lot of attention.\nThe only drawback was storage capacity - mine one had a 30 GB HDD, and although it was possible to find a unit with 80 gigs, it also wouldn\u0026rsquo;t be sufficient. Another option was to get a 6/7 generation one with 160 GB HDD, but I wanted to stay with the 5.5th gen unit.\nHardware mod 5th generation of iPods uses 1.8\u0026quot; ZIF HDD, which has an IDE interface with a different shaped connector. There is a number of available replacements:\n SD or CompactFlash adapter with the corresponding memory card — both adapter and large memory card are pricey, but among modding scene, it was the most popular option; 1.8\u0026quot; SSD with ZIF connector — quite a niche thing, which also makes it rather expensive; mSATA SSD with the adapter to ZIF — the least popular option for modding an iPod, but compared to the other options, was the best bang for the buck.  The last option was the most compelling for me, so I ordered an mSATA to ZIF adapter based on JM20330 chip (you can find it on eBay searching for \u0026ldquo;zif msata\u0026rdquo;) and a 250 GB Samsung 850 EVO mSATA SSD (its predecessor, 840 EVO had one of the greatest power characteristics, so it was a good choice). Also, I ordered some generic mSATA to regular SATA adapter, which unexpectedly played a great role in the whole project.\n Fun fact: 5th generation of iPod has 32 or 64 MB of SDRAM memory (depending on stock HDD capacity), while the ordered SSD has 512 MB of LPDDR3.\n When all the parts were delivered, at first I took the spare back cover and the main chassis from another dead iPod and put the mSATA-ZIF adapter between them. As you can see, the clearance was quite tight, there was less than a millimeter for adhesive and isolation.\nAt first, I thought of getting a back cover from a 60/80 GB unit, which is thicker, but I wanted to keep an old thin one. Also, when the SSD was plugged into the adapter, there was a noticeable gap between boards, which was quite a waste of space.\nThen I took a look at the SATA-mSATA adapter and noticed that it had a connector with the same footprint, but was a bit shorter.\nStacking boards together showed that the connectors' height difference was very similar to the size of the gap between SSD and mSATA-ZIF adapter.\nDelighted with this coincidence, I took my Rose\u0026rsquo;s metal and hot air soldering station, swapped the connectors, and filed down mounting standoffs to the correct height.\nAfter doing that, the SSD was flush with the mSATA-ZIF adapter board.\nSo I put a piece of isolation between the boards, plugged the SSD into the adapter, and tightened the mounting screws.\nWhen I put the resulting sandwich between spare iPod\u0026rsquo;s case parts, there were almost 2 millimeters of clearance, which was more than enough for securing the new components in place.\nAfter that, I put a layer of isolation to the back cover, added another piece of isolation to the backside of the adaptor board, plugged the ZIF flex cable to the adapter, secured it on the chassis with double-sided tape, and added stripes of packaging material to fill the void space.\nI wanted my iPod to be formatted in FAT32, so I had to use iTunes on Windows PC. After connecting an iPod I tried to restore it with iTunes, but the process was aborted with an error. After some troubleshooting, I figured out that the problem was in the NTFS partition on the SSD, which I created earlier to test the drive. I formatted it externally in FAT32, put back into the iPod and this time was able to restore it with iTunes.\nThe device was working and this could be the end of the story, but I decided to install Rockbox.\nRockbox After the trivial process of installing the custom firmware with Rockbox Utility and rebooting the iPod, I was greeted with the ATA error: -11. At the same time, stock firmware was still working fine. After some googling, I found a thread on Rockbox Forums, where the problem was investigated by the development team and solved by the user beyondwind. He also started a thread on Head-Fi Forums, where he posted some additional information. Unfortunately, at the moment of doing the mod, his website was down. Although it was possible to take a glance at it with help of Wayback Machine, almost all the content was unavailable. All, except the file ipod5g_msata_mod.patch, which undoubtedly was the most important. Also, it was saved on GitHub Gist by one of the users at Rockbox Forums.\nSo, with the patch in my possession, it was possible to build a patched firmware myself. Fortunately, Rockbox Wiki has a detailed guide for building firmware from scratch. The steps for doing so are well described, but I have some notes to make.\n1. Getting the source After cloning the repository, you can already apply the patch. It can be done with a bash command patch -p1 \u0026lt; path_to_file. Important notice about the patch file — the initial version had some changes for the plugin test_disk.c and included it in the regular build. The plugin code was highly modified since then and this part of the patch wasn\u0026rsquo;t applicable anymore, so I made the patch file without the mentioned pieces.\n2. Building a cross-compiler Automatic build works fine, but there are 3 caveats:\n I had a lot of difficulties building it on macOS Catalina. After 2 evenings of figuring out the origins of an endless stream of errors, I fired up a VM with Ubuntu 20.04.1 and was able to build the cross-compiler from one of the first tries. Although, a few years ago, when I built it for the first time, I was able to do it without a headache on macOS Sierra; The master branch sometimes can be broken. If you have difficulties with building, try checking out a bit earlier commit. For example, this one worked fine when I was building on Ubuntu; Make sure that all the dependencies listed on the wiki page are installed — initially, I have issues because of lacking texinfo.  3. Building Rockbox Fortunately, there were no issues here!\nIf everything was done correctly, after copying the freshly built .rockbox directory to the iPod it should just work. Finally, it\u0026rsquo;s time to copy some tunes and listen to them on your modded device!\nAnd also, there\u0026rsquo;s a patched build if you need it but don\u0026rsquo;t want to deal with patching and building.\nAfterword I accomplished this mod in January 2018 and was using the device almost every day since then. Later, I had to replace a battery because the old one dies of old age, but even with the old battery, there were no issues. Battery life is great, access time is instantaneous, and the weight loss is quite perceptible (an old HDD weight is close to the weight of the rest of the iPod). I\u0026rsquo;d recommend doing it to everyone who wants to give a second life to this classic device!\nFiles  ipod5g_msata_mod.patch — initial patch file by beyondwind; ipod5g_msata_mod_wo_plugin.patch — modified patch with removed changes for test_disk.c plugin, prefered for using; rockbox_msata_mod.zip — patched build from this commit. ","date":"2020-10-15","permalink":"https://agarmash.com/posts/ipod-classic-ssd/","tags":["ipod","ssd","rockbox"],"title":"A Journey of Putting an SSD Into an iPod Classic With Rockbox"},{"content":" Initially, I wrote this article for Distillery Tech Blog back in 2018. I decided to copy it here for the further preservation.\n Nowadays, everyone values privacy and security. That’s why it wasn’t surprising when, recently, we needed to use an encryption library on one of the projects.\nFor the project in question, the decision was made to use libsignal. Originally developed for Signal Private Messenger, libsignal has a good reputation among security specialists.\nUsing libsignal At the end of July 2018, there were implementations of libsignal in C, Java, and JavaScript. There was also an implementation in Objective-C called SignalProtocolKit, but at that time it had already been deprecated.\nOur goal was to use the library in an iOS app written in Swift. To keep everything up to date, we had to use the one written in C, for which the source code is stored here. Lucky for us, Swift can interact with C code very smoothly, at minimum because some of Apple’s low-level libraries are written in C. The tricky part was to add the library to the project correctly.\nCreating a module.map After a bit of research, I figured out that I could simply add the library’s source code to the project and create a module.map file to specify which headers of the library I wanted to expose (for more detail, check out this blog). libsignal contains lots of header files, but if I want to use it in a regular C project, I only have to include the one called signal_protocol.h. Since signal_protocol.h includes the other headers it depends on, just as every other header file does, we can be sure that all the files are included. Accordingly, I made a module.map file with the following contents:\nmodule SignalProtocol [system] { header “src/signal_protocol.h” export * }  Then, I put it into the folder with the library sources, added it to the project, and started to test.\nXcode allowed to import this module and to use some of the library functions, but some of the library components were missing. For example, I was unable to use the signal_context data type which is defined in signal_protocol_internal.h.\nAt that moment it became obvious that Xcode doesn’t properly include nested headers. So I decided to try including all the headers from libsignal in my module.map file. (It’s redundant to put the updated module.map here, as it just includes every *.h file similar to the file above.)\nAfter I did this and tried to build to build the project, I got a lot of errors related to some of the header files from libsignal. When I took a look at them, I realized that there were some header files that were not actual headers. Instead, they store some constant values and are used as follows:\nstatic const fe sqrtm1 = { #include “sqrtm1.h” } ;  As of the end of July 2018, the following files were used that way:\nsqrtm1.h ge_sub.h pow225521.h ge_add.h d2.h ge_madd.h ge_msub.h pow22523.h ge_p2_dbl.h d.h base2.h base.h  Finally, after excluding these files from my module.map, I was able to build the project and use all the parts of libsignal.\nWas it a victory? A moderate one, I guess. Adding the sources of a third-party library directly to the project didn’t seem quite right, so we decided to wrap libsignal in the Cocoa Touch Framework.\nWrapping It in the Cocoa Touch Framework At first, after all the previous difficulties, I thought this part would be easy. Unfortunately, I was proven wrong the exact moment I opened the Build Settings of our freshly created project framework and couldn’t find the “Swift Compiler — Search Paths” section.\nWhat followed were several attempts to include the libsignal sources in the framework. I will only describe the one that was successful.\nTo wrap a С library in the Cocoa Touch Framework (using the example of libsignal), follow these steps:\n1. Create a New Project Create a new project. For its type, choose “Cocoa Touch Framework.”\n2. Add Source Files Add the source files of the library to the project.\n3. Select Headers to Expose Go to the project file and select your target framework. Open the “Build Phases” tab. Here, in the “Headers” section, all the headers from the library should appear. Decide which ones to expose by dragging them to the “Public” list. In the case of libsignal, I decided to make all the headers public.\nBy the way, here you should have all the *.h files, even those that just store constants.\n4. Import Headers Now, since all the headers have been added to your project, you have to import them into the main header of the framework, which should be called [your framework name].h and placed in the root directory of the framework. Add the following line for every actual header, omitting those that just store constants:\n#import “protocol.h”  Note that, since we added all headers to the project file, we only have to use filename without specifying the whole path to the file in the project. It works this way because all of the headers are copied inside the framework bundle, and all paths inside the project become invalid.\nVoilà! You should have a fully functioning framework.\nDo note, however, that at the moment, it has one major disadvantage: It keeps a particular version of libsignal and doesn’t allow you to update it from its GitHub repository. That issue, however, is outside the scope of this article.\n","date":"2020-09-30","permalink":"https://agarmash.com/posts/c-library-in-swift/","tags":["c","swift"],"title":"How to Integrate a C Library into an iOS App Written in Swift"}]