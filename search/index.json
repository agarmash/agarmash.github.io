[{"content":"In this post, we\u0026rsquo;re going to dissect a very simple challenge from Hack the Box, \u0026ldquo;Behind the Scenes\u0026rdquo;. We\u0026rsquo;ll also look at how to work with Unix signals and how to skip illegal instructions in executables. Buckle up!\nCracking the challenge First of all, let\u0026rsquo;s try running the challenge executable.\nThe program expects a single argument with a password. Neat. Running strings over the executable haven\u0026rsquo;t yielded anything interesting, so let\u0026rsquo;s look at its internals with Ghidra.\nLooking at the main function, we can see some Unix signals trickery at the beginning, and the endless loop with the invalidInstructionException(); in the end.\nLet\u0026rsquo;s begin with the latter. While selecting the invalidInstructionException(); instruction in the decompilation, Ghidra highlights the following assembly instruction:\n001012e6\t0f 0b\tUD2  Referring to Intel® 64 and IA-32 Architectures Software Developer Manual, Vol. 2B, UD2 \u0026ldquo;generates an invalid opcode exception. This instruction is provided for software testing to explicitly generate an invalid opcode exception. The opcodes for this instruction are reserved for this purpose.\u0026rdquo;\nGhidra stops disassembling the file after the first occurrence of UD2. It makes total sense, by default the whole program will be terminated due to receiving a SIGILL Unix signal. However, there\u0026rsquo;s clearly more code after that instruction:\nSo, first of all, let\u0026rsquo;s select the rest of the code that hasn\u0026rsquo;t been disassembled and disassemble it by pressing \u0026ldquo;D\u0026rdquo;. As we can see, it\u0026rsquo;s indeed the executable code:\nNext, let\u0026rsquo;s replace all occurrences of the UD2 instruction with a NOP (there are a few dozens of them scattered across the main function). After doing so, we can immediately see that there are 4 strcmps comparing the user input with string constants. And the flag seems to be a concatenation of these constants:\nBy inputting the concatenated value into the program, we can verify that it\u0026rsquo;s the correct flag. Easy, huh?\nBut how does it work? That\u0026rsquo;s a good question, let\u0026rsquo;s figure it out.\nAs I\u0026rsquo;ve mentioned earlier, the operating system sends a SIGILL signal to the program trying to execute an illegal instruction. But can we skip the illegal instruction and continue the execution? The answer is yes, and that\u0026rsquo;s what the program does by registering a custom signal handler.\nInstalling a signal handler Let\u0026rsquo;s take a look at the decompiled fragment of the main once again:\nLet\u0026rsquo;s break it down:\n Line 6, a property of type sigaction is defined. For convenience, I renamed it to sa; Line 10, sa gets filled with zeroes to clear the allocated memory. We can make an educated guess that initially, it looked like memset(\u0026amp;sa, 0, sizeof(struct sigaction)), but the compiler was able to replace the sizeof call with a constant value; Line 11, sa.sa_mask is cleared out by calling the sigemptyset function; Line 12, a pointer to the local signal handler function segill_sigaction is assigned to the sa.sa_sigaction (named by Ghidra as sa.__sigaction_handler); Line 13, the value of SA_SIGINFO flag is assigned to the sa.sa_flags (#define SA_SIGINFO 0x00000004 in signal.h); Line 14, the constructed sa structure is assigned as a handler for a SIGILL signal (#define SIGILL 4 in signal.h) by calling the sigaction function (yes, the structure and the function are named identically).  Handling the received signal The next piece of the puzzle is the signal handler function, segill_sigaction in our case.\nThe signature of the handler function is void handler(int sig, siginfo_t *info, void *ucontext). As sigaction(2) page states, these three arguments are as follows:\n int sig: The number of the signal that caused invocation of the handler; siginfo_t *info: A pointer to a siginfo_t, which is a structure containing further information about the signal; void *ucontext: This is a pointer to a ucontext_t structure, cast to void *. The structure pointed to by this field contains signal context information that was saved on the user-space stack by the kernel.  Page sigaction(3p) also states that new applications should explicitly cast the third argument of the signal handling function to ucontext_t *.\nLet\u0026rsquo;s retype the 3rd parameter and take a look at the decompilation:\nFirst of all, let\u0026rsquo;s take a look at the ucontext_t structure contents. As The GNU C Library Reference Manual states, it should include at least the following fields:\n ucontext_t *uc_link: This is a pointer to the next context structure which is used if the context described in the current structure returns; sigset_t uc_sigmask: Set of signals which are blocked when this context is used; stack_t uc_stack: Stack used for this context. The value need not be (and normally is not) the stack pointer; mcontext_t uc_mcontext: This element contains the actual state of the process. The mcontext_t type is also defined in this header but the definition should be treated as opaque. Any use of knowledge of the type makes applications less portable.  Aha, we\u0026rsquo;re getting closer. Let\u0026rsquo;s take a look at the excerpt from the glibc sources for the x86-64 architecture containing the mcontext_t definition and some of its nested data types:\n/* Context to describe the whole processor state. */ typedef struct { gregset_t __ctx(gregs); fpregset_t __ctx(fpregs); __extension__ unsigned long long __reserved1 [8]; } mcontext_t; /* Container for all general registers. */ typedef greg_t gregset_t[__NGREG]; /* Number of each register in the `gregset_t' array. */ enum { REG_R8 = 0, # define REG_R8\tREG_R8 REG_R9, # define REG_R9\tREG_R9 REG_R10, # define REG_R10\tREG_R10 REG_R11, # define REG_R11\tREG_R11 REG_R12, # define REG_R12\tREG_R12 REG_R13, # define REG_R13\tREG_R13 REG_R14, # define REG_R14\tREG_R14 REG_R15, # define REG_R15\tREG_R15 REG_RDI, # define REG_RDI\tREG_RDI REG_RSI, # define REG_RSI\tREG_RSI REG_RBP, # define REG_RBP\tREG_RBP REG_RBX, # define REG_RBX\tREG_RBX REG_RDX, # define REG_RDX\tREG_RDX REG_RAX, # define REG_RAX\tREG_RAX REG_RCX, # define REG_RCX\tREG_RCX REG_RSP, # define REG_RSP\tREG_RSP REG_RIP, # define REG_RIP\tREG_RIP REG_EFL, # define REG_EFL\tREG_EFL REG_CSGSFS, # define REG_CSGSFS\tREG_CSGSFS REG_ERR, # define REG_ERR\tREG_ERR REG_TRAPNO, # define REG_TRAPNO\tREG_TRAPNO REG_OLDMASK, # define REG_OLDMASK\tREG_OLDMASK REG_CR2 # define REG_CR2\tREG_CR2 };  As we can see, the field gregs contains all the saved CPU registers.\nAt this point, let\u0026rsquo;s refer back to sigaction(3p) that states that \u0026ldquo;when the signal handler returns, the receiving thread resumes execution at the point it was interrupted unless the signal handler makes other arrangements\u0026rdquo;. In our case, we deliberately want to resume the execution after skipping the invalid instruction. Since the UD2 operation is 2 bytes long, we can achieve that by incrementing the RIP register by 2.\nIn C, it would look like this:\nucontext-\u0026gt;uc_mcontext.gregs[REG_RIP] += 2;   Important note: this solution is quite hacky and tied up to run strictly on x86-64 POSIX-compliant systems. Don\u0026rsquo;t do this in any production code.\nThe only possible exception is if you deliberately trying to do some bizarre obfuscation, this can be one of your tools - since you have the access to all the saved context, it\u0026rsquo;s possible to change the values of the general-purpose registers, jump to another address by modifying the instruction pointer, and do another weird stuff (:\n Compare it with what the Ghidra decompiled. Looks quite similar, isn\u0026rsquo;t it? :)\nThe only difference is that Ghidra wasn\u0026rsquo;t able to figure out the name of the register and just provided its index in the array, 0x10. We can manually verify that it\u0026rsquo;s the correct index of the REG_RIP. Alternatively, we can print the index of REG_RIP by running this snippet of code, which in turn prints 0x10:\n#define __USE_GNU #define _GNU_SOURCE #include \u0026lt;stddef.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;ucontext.h\u0026gt; void main() { printf(\u0026quot;0x%x\\n\u0026quot;, REG_RIP); }  Another way of doing that is to find the offset in the whole ucontext_t structure. Imagine that we only have the assembly listing of the function, which looks like this:\nAfter some argument shuffling, the address of the ucontext gets stored in the local_ucontext variable. Its value at the offset 0xa8 is loaded into the RAX, incremented by 2, and written back into the structure.\nFor the reference, function decompilation looks like this:\nBy making an educated guess we assume that the function increments the RIP register. We can find it\u0026rsquo;s offset in the structure by running the following snippet of code:\n#define __USE_GNU #define _GNU_SOURCE #include \u0026lt;stddef.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;ucontext.h\u0026gt; void main() { size_t rip_offset = offsetof(ucontext_t, uc_mcontext.gregs[REG_RIP]); printf(\u0026quot;0x%x\\n\u0026quot;, rip_offset); }  It prints 0xa8, which matches the offset in both the assembly listing and the decompilation.\nCombining it all together Now let\u0026rsquo;s combine all the pieces of the puzzle together. Here\u0026rsquo;s a simple program which conceptually works the same as the challenge binary:\n#include \u0026lt;stdio.h\u0026gt; #define __USE_GNU #include \u0026lt;signal.h\u0026gt; #include \u0026lt;string.h\u0026gt; void sighandler (int signo, siginfo_t *info, void *context) { ucontext_t *uc = (ucontext_t *)context; int instruction_length = 2; // The length of the \u0026quot;instruction\u0026quot; to skip uc-\u0026gt;uc_mcontext.gregs[REG_RIP] += instruction_length; } void main() { struct sigaction sa; memset(\u0026amp;sa, 0, sizeof(struct sigaction)); sigemptyset(\u0026amp;sa.sa_mask); sa.sa_flags = SA_SIGINFO; sa.sa_sigaction = sighandler; sigaction(SIGILL, \u0026amp;sa, NULL); printf(\u0026quot;%s\u0026quot;, \u0026quot;Reachable\\n\u0026quot;); asm(\u0026quot;ud2\u0026quot;); // Adding an illegal opcode printf(\u0026quot;%s\u0026quot;, \u0026quot;Unreachable\\n\u0026quot;); }  All in all, the resulting code is quite similar to the accepted answer to this question on Stack Overflow.\nAfter compiling and executing it prints the following:\nComparing the binaries In conclusion, let\u0026rsquo;s compare the decompilation of our recreated binary (on the left, compiled with gcc (GCC) 12.1.0) and the one from the challenge (on the right):\nIt\u0026rsquo;s surprising how similar they are, and how close the decompilation is to the source code!\nThat\u0026rsquo;s it for today. Thanks for reading, and happy hacking!\nFurther reading  Linux Signals for the Application Programmer, Linux Journal ","date":"2022-06-13","permalink":"https://agarmash.com/posts/htb-behindthescenes-writeup/","tags":["HackTheBox","CTF","Writeup"],"title":"Hack the Box \"Behind the Scenes\" Writeup, or How to Skip Illegal Instructions in Executables"},{"content":" Originally posted in Akvelon Blog\n While working on one of the apps, we faced the need to trim the recorded audio files. We were working with 32-bit float WAV files, and we had the following requirements:\n the output file should have the exact same format as the input file; no processing should be applied to the audio data, audio samples should be copied as-is; there should be an ability to add silence to the output file.  My first guess was to use AVAssetExportSession, but it has limited options for exporting the audio, and it’s not possible to be sure what it does with the audio under the hood. A no-go.\nSecondly, I took a look at the requirements again. \u0026ldquo;Audio samples should be copied as-is\u0026rdquo;. That was exactly what we needed - to open the input file for reading, the output one for writing, calculate the range of audio samples to copy, and perform the actual copying. Fortunately, it was completely possible with AVAudioFile - it can be read into AVAudioPCMBuffer and written from one\u0026rsquo;s contents.\nA few words regarding the output format While working on implementing this functionality, I was sure that AVFoundation converts the data to the set format of the output file on the fly. However, as later turned out, the header of the output file matched the set format, but the actual audio data had the format of the internal processing with AVFoundation (32-bit float WAV).\nIt’s possible to use AVAudioConverter to convert the audio to the desired format, but this is out of the scope of this article.\nAlso, keep in mind that multiple conversions from lossy to lossy format (like MP3 or AAC) will degrade the audio quality. Theoretically, it’s possible to copy the lossy audio data directly, like mp3DirectCut does, but this is also a thing to figure out yourself.\nPreparation First, we have to open the input file for reading, get some information about it, and open the output file for writing.\nOpening the file for reading is simple:\nlet inputFile: AVAudioFile = try! AVAudioFile(forReading: inputFileURL)   Note: All the force unwraps, force tries, and fatalError()’s were added to keep the code examples concise. In the real app, all these things should be handled properly.\n After doing so, we can take a look at 2 important properties of the opened file:\n fileFormat: AVAudioFormat - the format of the audio file itself; processingFormat: AVAudioFormat - the format that AVFoundation will use to process the audio.  As I mentioned earlier, the format of our files matched the internal processing format of AVFoundation. That’s why it was possible to use fileFormat for allocating audio buffers and exporting audio data. When I tried an input file with even a slightly different format, everything went down in flames. In the course of the article, I’ll be using processingFormat as the correct one for manipulating audio data.\nFor our task, we’re going to use the following properties of the input file:\n processingFormat: AVAudioFormat - see above; processingFormat.sampleRate: Double - the sample rate of the audio file; length: Int64 - the length of the audio file in samples.   Note: In case digital audio is Greek to you, and you have no clue what the sample rate is, here’s a great article describing the basics.\n Later, we\u0026rsquo;re going to need the processing format, its sampling rate, and duration in seconds. Let\u0026rsquo;s define them as the new properties for convenience:\nlet processingFormat = inputFile.processingFormat let sampleRate = Int(processingFormat.sampleRate) let duration = Double(inputFile.length) / Double(sampleRate)   Note: In this article, we’re going to cast a lot of values to the different types. At some point, it will become a total mishmash.\n Then we can open the output file for writing, setting it up with the processing format:\nlet outputFile: AVAudioFile = try! AVAudioFile( forWriting: outputFileURL, settings: processingFormat.settings, commonFormat: processingFormat.commonFormat, interleaved: processingFormat.isInterleaved)  Also, looking a bit ahead, let\u0026rsquo;s define the default buffer size that we\u0026rsquo;re going to use. In my experience, buffer with the size of the sample rate (e.g. storing one second of the audio) works just fine:\nlet defaultBufferSize = sampleRate  Finally, we are prepared for the action. It\u0026rsquo;s time to copy some audio data!\nCopying the arbitrary segment of the audio file We\u0026rsquo;ll start with the case where we have to copy a segment of the audio file. Let\u0026rsquo;s define the start and the end time, and check that they are valid:\nlet startTime: Double = 1.0 let endTime: Double = 2.0 guard startTime \u0026lt; endTime, startTime \u0026gt;= 0, endTime \u0026lt;= duration else { fatalError() }  Then we have to figure out the offset of the segment and its duration in samples:\nlet offset = Int64(Double(sampleRate) * startTime) var samplesToCopy = Int(Double(sampleRate) * (endTime - startTime))  Now the interesting part begins. AVAudioFile has framePosition property - \u0026ldquo;the position in the file at which the next read or write operation will occur\u0026rdquo; as the documentation says. It gets automatically advanced on reading or writing operation by the number of frames read or written respectively. Fortunately for us, it can also be set manually to perform a seek before a read or write. As you might have guessed, this is what we computed the offset for:\ninputFile.framePosition = offset  Finally, it\u0026rsquo;s time to copy the audio data. Let\u0026rsquo;s take a look at the complete code snippet and break it apart right after:\n// 1 while samplesToCopy \u0026gt; 0 { // 2 let bufferCapacity = min(samplesToCopy, defaultBufferSize) // 3 let buffer = AVAudioPCMBuffer( pcmFormat: processingFormat, frameCapacity: AVAudioFrameCount(bufferCapacity))! // 4 try! inputFile.read(into: buffer) try! outputFile.write(from: buffer) // 5 samplesToCopy -= Int(buffer.frameLength) }   Repeat the process until the whole number of samples is copied; Define how many samples to copy during the iteration. At some point, the remaining number of samples to copy will be less than a default buffer size, so this should be used as a buffer size instead; Instantiate the buffer with the proper audio format and the determined size; Read the input file into the buffer and write it into the output file. Important note: the documentation says that the system will try to fill the buffer to its capacity, but it\u0026rsquo;s not guaranteed. That\u0026rsquo;s why we\u0026rsquo;re repeating the loop until the desired number of samples is copied rather than copying a precalculated number of the buffers; Decrease the sample counter by the number of actually copied samples.  And the last step - to write the complete output file into the disk, the outputFile has to be deinitialized, which can be achieved by removing all its strong references (if you only referred to it from the property declared inside a method, then it will happen when the method returns). Not as scary as it could be, right?\nCopying the last part of the audio file Now let\u0026rsquo;s look at how we can cut some corners if we only need to copy the \u0026ldquo;tail\u0026rdquo; of the audio file with the desired length.\nThis time we\u0026rsquo;ll define a segment duration and check its validity:\nlet segmentDuration: Double = 4.0 guard segmentDuration \u0026lt;= duration else { fatalError() }  Offset calculation is also pretty straight-forward:\nlet offset = inputFile.length - Int64(Double(sampleRate) * segmentDuration) inputFile.framePosition = offset  And here lies the main difference - instead of calculating how many samples should be copied, we just perform the copying until we reach the end of the input file:\nwhile inputFile.framePosition \u0026lt; inputFile.length { let buffer = AVAudioPCMBuffer( pcmFormat: processingFormat, frameCapacity: AVAudioFrameCount(defaultBufferSize))! try! inputFile.read(into: buffer) try! outputFile.write(from: buffer) }  This is one of the practical examples of the situation when the buffer may not be filled completely if there\u0026rsquo;re not enough samples left in the input file.\nThe rest is identical - deinit the output file and you are free to go!\nAdding silence to the output file Now let\u0026rsquo;s add some silence to the output file, for example, to round up its duration. Obviously, we need a buffer which we will later write into the output file. Let\u0026rsquo;s begin with obtaining one:\nlet silenceDuration: Double = 0.7 let silenceLength = silenceDuration * Double(sampleRate) let buffer = AVAudioPCMBuffer( pcmFormat: processingFormat, frameCapacity: AVAudioFrameCount(silenceLength))!  Since in our case we had to add no more than a second of silence, we used a single buffer, but if you consider adding hours of silence, it\u0026rsquo;s better to work with small buffers in a loop similar to what we did earlier.\nNow we have an empty buffer, and it has to be filled with silence somehow. The first thing that interests us is the buffer\u0026rsquo;s frameCount property, which represents the number of valid audio frames in the buffer. Its value can be changed manually, so to make the buffer look like it\u0026rsquo;s filled up with data, we can do the following:\nbuffer.frameLength = buffer.frameCapacity  If you try to write this buffer into the file now, it may work, especially if you\u0026rsquo;re testing it in a debug build. However, there\u0026rsquo;s no guarantee that the buffer\u0026rsquo;s memory will be zeroed out in the release build, so in the wild, you can get anything but silence.\nTherefore, we need to fill the buffer with zeros manually. We\u0026rsquo;ll go a dangerous way, using the old infamous memset. Some smart people call it the most troublesome function in history, so it wouldn’t hurt to double-check that everything is implemented correctly. This approach was described by theanalogkid on the Apple Developer Forums with the sample code written in Objective-C. Here’s how the implementation in Swift code looks:\n// 1 let bytesPerFrame = Int(processingFormat.streamDescription.pointee.mBytesPerFrame) // 2 guard let channelDataPointer = buffer.floatChannelData else { fatalError() } // 3 for channel in 0..\u0026lt;Int(processingFormat.channelCount) { // 4 memset(channelDataPointer[channel], 0, silenceLenght * bytesPerFrame) }  Here\u0026rsquo;s what we do:\n Getting the size of a single audio frame in bytes; Getting a pointer to the buffer with the audio data. Since we\u0026rsquo;re working with floating-point audio, the buffer we\u0026rsquo;re looking for is floatChannelData. All the 3 buffer referring properties (float, int16, and int32) are optional, so if you’re unsure about the audio data format, it’s possible to optional chain them like buffer.floatChannelData ?? buffer.int16ChannelData ?? buffer.int32ChannelData; Iterating through the indexes of the audio channels; For each audio channel, writing the exact number of zeroed bytes to fill all the audio frames.  Now the buffer can be safely written to the file, and that\u0026rsquo;s it. We just added some silence to the audio file. As always, don’t forget to close the output file when you’re done writing into it.\nConclusion As you can see, it’s not that hard to do the basic audio file trimming without using any 3rd-party libraries. The described techniques can be applied further, for example, to compose pieces of the audio file in arbitrary order or to concatenate multiple audio files. The only drawback is the need to convert the audio to the desired output format manually.\n","date":"2021-12-26","permalink":"https://agarmash.com/posts/avfoundation-audio-trimming/","tags":["Swift","AVFoundation"],"title":"Trimming Audio Files and Adding Silence with AVFoundation in Swift"},{"content":"A story about reverse engineering and way too smart FTP client\nSome time ago, I decided to swap HDD in my Original Xbox. It already has been upgraded with a 40 Gb IDE drive, but I had a spare 160 Gb SATA drive laying around and wanted to have some more storage in the system. I bought a SATA to IDE converter, swapped the drives, installed the system software, and transferred all the content back. To my utmost disappointment, savefiles for some games were corrupted. One of them was Black, where I had a decent amount of played hours. I did some basic troubleshooting but wasn\u0026rsquo;t able to find the source of the problem. At that moment it was obvious to me that the problem lay in the new hard drive.\n If you\u0026rsquo;re here to know how to patch a game\u0026rsquo;s binary, jump straight to the Patching the binary yourself.\n OG Xbox Savefiles 101 To prevent any tampering, all the game developers were obliged to add a digital signature to the savefiles of their games.\nAdditionally, developers were able to make savefiles \u0026ldquo;non-roamable\u0026rdquo;, i.e. lock them to the particular console they were created on. For achieving that, Xbox has a so-called \u0026ldquo;XboxHDKey\u0026rdquo; - a per-console value stored in the EEPROM intended specifically for the content locking. The list of such games is well known and maintained by the community. However, Black wasn\u0026rsquo;t on the list. (While writing this post, I was able to find an extended list, and even find a resigner specifically for Black. Funny enough, it wouldn\u0026rsquo;t help me with the issue I had in the first place.)\nIf you want to dive deeper into the topic, those pages are for you:\n A thread in comments on Reddit by feudalnate_ \u0026ldquo;Xbox save resigning – a technical overview\u0026rdquo; by gothi  So, at that moment I was convinced that some additional checks were implemented in the game. I thought that probably HDD\u0026rsquo;s model and serial number were also used for the signature generating. There was only one way to know for sure.\nReverse engineering and patching game\u0026rsquo;s executable I decided to analyze the executable binary with Ghidra. To be able to do so, I additionally grabbed ghidra-xbe, an extension for the Ghidra to support loading Xbox Executable Format (XBE) files, and xbox-includes, a set of GPL-sourced Xbox headers. Loading and analyzing the game\u0026rsquo;s executable was straightforward, but importing headers had a quirk. For some reason, Ghidra wasn\u0026rsquo;t happy with the HANDLE type, but renaming it to something different like HANDLE_MY solved the problem.\nNow we are fully prepared to begin digging. Searching for the word \u0026ldquo;signature\u0026rdquo; in the program text immediately yielded some promising results:\nA lot of recovered (or maybe unstripped?) symbols, the most interesting of which is \u0026ldquo;XCalculateSignatureBegin\u0026rdquo;. Quick googling gave me the following function definitions from the XAPI:\nHANDLE XCalculateSignatureBegin(DWORD dwFlags); DWORD XCalculateSignatureUpdate(HANDLE hCalcSig, BYTE* pbData, ULONG cbData); DWORD XCalculateSignatureEnd(HANDLE hCalcSig, BYTE* pbSignature);  By making an educated guess, we can assume that 1st function creates a handle object set up with some flags, 2nd one takes the binary data and its size to calculate the signature for, and the last one writes the signature into the provided address. The flags are also conveniently listed on the page mentioned above, but we\u0026rsquo;ll get to them later.\nNow we can complete the function signature and take a look a look at its callers. There are 2 of them, and for the reader\u0026rsquo;s convenience, we\u0026rsquo;ll start with the 2nd one. This is how it looks after decompilation:\nThe obtained handler is checked not to be -1, and after that 2 functions are called, whose parameters are suspiciously similar to XCalculateSignatureUpdate and XCalculateSignatureEnd. After completing their signatures the decompiled code of the function started to look like this:\nNow let\u0026rsquo;s take a close look. The ~Update function takes EAX as the pointer to the source data and 0x17ec as the data length. The ~End function takes EAX advanced by the same 0x17ec bytes. Most of the games stored the signature at the end of the savefile, so we can conclude that this function is responsible for adding the signature to the savefile while saving the game. You can be creative and replace this function implementation to add some custom data instead of the signature. Does anyone want to place an ad to the savefile of the 15 years old game where nobody will ever see it? No? Okay, let\u0026rsquo;s move forward then.\nNow we\u0026rsquo;ll take a look at the 1st of 2 callers. Its decompiled code looks like this:\nHere, the ~Update function gets called identically, but the ~End function takes a pointer to the local 20 bytes long variable as its second parameter. Perfect! The rest of decompiled code looks like total gibberish, so let\u0026rsquo;s take a look at the assembly listing:\nAfter calling the ~End function, pointers to the signature from the savefile and calculated signature get loaded to the EDI and ECI respectively, signature length gets loaded to ECX, and they got compared by the following instruction:\n001f2dfd f3 a6 CMPSB.REPE ES:EDI,ESI  If the comparison is successful, i.e. the difference between signatures is 0, the following conditional jump gets performed:\n001f2e01 74 05 JZ LAB_001f2e08  The rest of the code is some compiler optimized preparation of the return value, which is not interesting. What\u0026rsquo;s interesting is to skip the code that gets executed if the check was not successful. The most straightforward thing to do is to replace the conditional jump with an unconditional one. It can be achieved by changing the instruction from JZ (opcode 74) to JMP (opcode EB). After doing so, saving the patched binary, and transferring it to the directory with the game backup on the Xbox via FTP, I was ready for testing. Unfortunately, an unexpected discovery has happened.\nA terrible mistake With patched binary, I also transferred my old savefile to the console. And I noticed something. The savefile size on my computer was 6144 bytes, while on the console it was a few bytes larger, something like 6147 bytes. I took a few seconds to digest it and then realized that I made a terrible mistake. As I figured out, FileZilla, an FTP client that I used automatically corrects line breaks while transferring text files between Windows and Unix systems, and by default, it treats files without an extension as text files. So, while I was thinking about some sophisticated anti-tampering system in the game, my FTP client was just corrupting the files.\nAfter properly configuring FileZilla, I copied the savefile to the console, verified its size, launched the game from the vanilla executable, and it loaded the savefile normally. Just to verify whether my patch is working, I changed a few bytes in the savefile signature, copied it to the console, launched the game from the patched binary, and it also loaded the savefile normally! Yay!\nIt could be the end of the story, but in the process, I found something else.\nSigning flags and non-roamable saves Remember the flag that is passed into the ~Begin function? If we look back at the decompiled code, the 1 is passed in both function calls:\nhCalcSig = XAPILIB::XCalculateSignatureBegin(1);  What does the 1 mean? Fortunately, the same Reddit page mentioned above gives us the answer:\nDWORD XCALCSIG_FLAG_NON_ROAMABLE = 0x00000001;  So, this precisely tells us that the game incorporates non-roamable savefiles. Their signatures are tied to a particular console with mentioned above XboxHDKey and can\u0026rsquo;t be transferred to another console. But since we disabled signature checking, they now can be!\nSo, to recap: this patch allows you to freely move the savefiles between consoles without any additional actions like resigning. And this is some great news!\nPatching the binary yourself For obvious reasons, I can\u0026rsquo;t distribute the patched binary. However, I can show you how to patch one. During my research, I was using default.xbe file marked as region-free (game region value in the xbe certificate is 7, which means all regions) with md5 hash d21025a12520a74a2edd6c86fef9b57e. The patching is simple - open the file with a hex editor, find a byte 74 at the offset 0x1E2E01, and replace it with EB. That\u0026rsquo;s it.\nIf there\u0026rsquo;s something different at the aforementioned offset, you can also try looking for the following byte sequence 74240833 C0F3A65F 5E74051B C083D8FF and replace its 10th byte as described above.\nTransferring savefiles without modifying the game If you don\u0026rsquo;t have an option to use the patched binary (for example, you prefer to run games from the original discs), it\u0026rsquo;s also possible to resign the savefile. You can find a standalone resigner for Windows, its source code, and additional config for XSavSig in the feudalnate\u0026rsquo;s GitHub repository.\nWrapping up So, what do I think about all this in the end? Was all this needed from the perspective of just playing video games? Not at all. Did I learn a lot about reverse engineering in the process? Absolutely yes! And I really enjoyed the process, it was quite interesting to dive deep and figure out how things work. And in the process, I somewhat contributed to video games preservation, which is also amazing!\nNow I can confidently say that the Original Xbox helped me learn some new skills and has a special place in my life!\n","date":"2021-12-09","permalink":"https://agarmash.com/posts/xbox-black-reverse-engineering/","tags":["Xbox","Reverse Engineering"],"title":"Patching Xbox Game Black to Disable Savefile Signature Checking"},{"content":"While implementing audio playback with AVAudioPlayer, you may need to display the playback progress with UIProgressView, or even to synchronize the state of the player with UISlider. AVAudioPlayer doesn\u0026rsquo;t have any functionality to get periodically notified about the current playback position. However, it has 2 aptly named properties that represent the time of the current playback position and the duration of the audio file: currentTime and duration respectively.\nBad approach - using Timer The first thing that comes to mind is to set up a Timer to periodically calculate the playback progress and to update the UI. Picking the right update interval also seems as easy as getting the refresh rate of the device\u0026rsquo;s screen and figuring out the duration of a single frame: 1 / Double(UIScreen.main.maximumFramesPerSecond). But here I have to stop you since this approach has a flaw - the timer isn\u0026rsquo;t synchronized with screen refreshing, so there\u0026rsquo;s no guarantee that each invocation of the timer will correspond with the new frame being drawn on the screen. This may cause an unpleasant jitter in the UI, and this phenomenon is covered in great detail in this article. Fortunately, there\u0026rsquo;s a more suitable alternative, and as you\u0026rsquo;ve guessed, I\u0026rsquo;m talking about CADisplayLink.\nBetter approach - using CADisplayLink CADisplayLink is a timer object that is synchronized with the refresh rate of the display. To learn more about it, check the documenation and this detailed article. Instead, let\u0026rsquo;s see how it can be applied to the task.\nImplementing UI updating At first, let\u0026rsquo;s implement updating of the UI components using the display link:\nclass AudioPlayerViewController: UIViewController { // 1 @IBOutlet weak var slider: UISlider! // or @IBOutlet weak var progressView: UIProgressView! // 2 var player: AVAudioPlayer // 3 lazy var displayLink: CADisplayLink = CADisplayLink(target: self, selector: #selector(updatePlaybackStatus)) // 4 func startUpdatingPlaybackStatus() { displayLink.add(to: .main, forMode: .common) } func stopUpdatingPlaybackStatus() { displayLink.invalidate() } // 5 @objc func updatePlaybackStatus() { let playbackProgress = Float(player.currentTime / player.duration) slider.setValue(playbackProgress, animated: true) // or progressView.setProgress(playbackProgress, animated: true) } }  Additional comments to the code:\n An outlet to the UI component you want to update. It can be UISlider, UIProgressView, or some custom view that shows the progress. If you stick with UISlider, make sure that its min and max values are set to 0 and 1 respectively. The same applies to custom views as well; A reference to the AVAudioPlayer, just for clarity; A property storing an instance of CADisplayLink. Since we use self as the target, the initialization of CADisplayLink should be done after initializing the parent class to be able to correctly reference it. For that purpose I made it lazy; Methods that start and stop updating the UI. You should call them when the playback status changes. The method that gets called during screen refresh, the logic for updating the UI is stored here.  That\u0026rsquo;s all that has to be done to update the UI component. However, if you want to use a slider for seeking through audio, some more things have to be done.\nAdding playback control with slider I\u0026rsquo;m going to replicate the behavior of the Music.app, where the audio position changes only at the moment of releasing the slider. Here\u0026rsquo;s what has to be added:\n// 1 @IBOutlet weak var slider: UISlider! { didSet { slider.addTarget(self, action: #selector(didBeginDraggingSlider), for: .touchDown) slider.addTarget(self, action: #selector(didEndDraggingSlider), for: .valueChanged) slider.isContinuous = false } } // 2 @objc func didBeginDraggingSlider() { displayLink.isPaused = true } @objc func didEndDraggingSlider() { let newPosition = player.duration * Double(slider.value) player.currentTime = newPosition displayLink.isPaused = false }   Add actions for slider\u0026rsquo;s touchDown and valueChanged events to get notified when the user begins and ends dragging the slider respectively. Also, set one\u0026rsquo;s isContinuous property to false, so the valueChanged event is reported only when the user releases the slider. This setup can also be done with Interface Builder and IBActions; Add the methods for handling slider\u0026rsquo;s events and implement fairly straightforward logic - pause display link when the user begins dragging the slider, so its value isn\u0026rsquo;t updated during user interaction; seek the audio to the selected position and resume display link when the user released the slider.  That\u0026rsquo;s all that has to be done to make the user experience of your app a bit sleeker!\n","date":"2021-03-10","permalink":"https://agarmash.com/posts/avaudioplayer-playback-progress/","tags":["Swift","AVAudioPlayer","UISlider","UIProgressView"],"title":"Using UISlider or UIProgressView to Display and Control the Playback Progress of AVAudioPlayer"},{"content":"I\u0026rsquo;ve accomplished this little project back in 2016 when I had two Xbox 360 wireless controllers and a huge desire to use them with a PC. To do so, you have to have a wireless receiver, and there were 2 mainstream options on the market:\n a genuine one - the best option, but costs around $60; an unofficial replica - can be found for $10-15, but reliability and driver support were quite questionable.  At that moment, I was short of money to get the first one and didn\u0026rsquo;t want to try luck with the second. Fortunately, if you dive a bit deeper into the topic and doesn\u0026rsquo;t afraid to do some soldering, there\u0026rsquo;s a third option - using an RF module from a broken Xbox 360 (later in the text I\u0026rsquo;ll refer to it just as \u0026ldquo;RF module\u0026rdquo;).\n If you just want to build your own device, jump straight to the Building the device.\n Connecting the RF module At the moment of working on the project thorough reverse engineering has already been done and documented. The authors figured out that the RF module communicates with Xbox 360 itself via 2 interfaces:\n A proprietary I2C-like protocol, for controlling LEDs and syncing with controllers; USB, for communicating with controllers.  The USB connection is quite straightforward - you need to connect the ground and data lines and supply 3.3 volts for the power. Being connected to the PC, the RF module works exactly like the official wireless receiver, the only difference is the PID of the device, but after manually installing the official driver everything works as it should.\nConnecting a control bus is more complicated, but there are a bunch of different options:\n Leave it unconnected. I haven\u0026rsquo;t tried that, but I\u0026rsquo;ve read that the RF module will work fine this way with the controllers that have been previously synced with it. I also read that it\u0026rsquo;s possible to sync a controller by connecting it via Play and Charge Kit to the same computer, but I haven\u0026rsquo;t verified that too. Using a Raspberry Pi. It can be quite handy if you plan to permanently use the RF receiver with Raspberry. It\u0026rsquo;s even possible to display things using the module\u0026rsquo;s LED ring, which can be a nice feature. Using an FT232RL and a program for Windows. I\u0026rsquo;ve checked this one, but it didn\u0026rsquo;t work for me. I tried to attach Saleae logic analyzer to data pins and it seems that my FT232RL\u0026rsquo;s IO wasn\u0026rsquo;t fast enough, seems like I\u0026rsquo;ve got a counterfeit chip. Also, that\u0026rsquo;s way too cumbersome for everyday use. Using an Arduino or a bare microcontroller (also called as MCU) (for example, ATTiny45). As for me, this is the best option since you\u0026rsquo;re getting a self-sufficient device.  Bringing AVR to the table I decided to use a microcontroller, and I wanted something that wouldn\u0026rsquo;t be overkill for this task. Fortunately, I had a few ATTiny13 laying around, which is more than enough for the given task. Also, I had a DIY development board based on ATMega16A, which was quite handy for working on the project.\nTo be sure that I implemented the communication protocol correctly and that my module wasn\u0026rsquo;t dead, I wrote the code that received a command via UART and sent it to the RF module. And it worked! Here\u0026rsquo;s a quick demo:\n  While testing different commands, I decided that the final implementation should allow to sync a new controller and to disable all the connected controllers. For doing so, I connected the power button from the RF module to the microcontroller too and implemented the following logic:\n After powering up, the MCU waits for 3.5s to allow the module to boot up properly and sends the \u0026ldquo;LED_INIT\u0026rdquo; command to initialize the LED ring and turn on the green LED in the center; After that, the MCU waits for the button press. On short press, it sends the \u0026ldquo;SYNC\u0026rdquo; command to sync with controllers, on the long press - sends the \u0026ldquo;CTRLR_OFF\u0026rdquo; command to power off all connected controllers and right after that send a bunch of commands to shortly turn on the led ring for the clarity.  Initially, I implemented the new logic for ATMega16, and when everything was working as intended, I ported it to ATTiny13, which was a matter of just changing a header file and GPIO ports mapping. When the firmware was ready, it was time to build the final device.\nBuilding the device Here\u0026rsquo;s the list of what you\u0026rsquo;ll need to build the standalone receiver:\n An RF module itself. You need the one from the first generation of Xbox 360 (so-called Fat model). Also, pay attention to the revision of the module - people discovered that Rev. A modules from Xenon consoles have problems with Windows 8 and have worse connectivity range, while Rev. B and the rest don\u0026rsquo;t have those issues. I\u0026rsquo;ve got a Rev. F module and had zero problems using it with Windows 7 and a wide range of macOS versions. RF modules from Slim and E models aren\u0026rsquo;t suitable - although people figured out how to connect the USB, the control bus seems to be different; AVR microcontroller. The firmware is simple and can be compiled with GCC AVR for any AVR chip with some minor changes. Both source code and the compiled binary for the ATTiny13 are stored in the project repo; A way to provide 3.3v power to the module - I used an 1117-33 LDO voltage regulator with filtering capacitors, but any voltage converter can be applied here; 3 pullup resistors, their optimal value is 10k ohm, but it will work with slightly different values too; A programmer for AVR, a USB connector to your taste, some hooking wire, soldering supplies - the standard stuff.  If you haven\u0026rsquo;t worked with AVR or with microcontrollers in general, don\u0026rsquo;t forget that you have to flash the firmware to the MCU. There are plenty of ways to do so, I used FT232RL from the hardware and avrdude from the software side.\nHere\u0026rsquo;s the connection diagram. The RF module\u0026rsquo;s connector is depicted as if you were looking on the front side of it:\nI decided not to bother with making the PCB and connected everything with hooking wires, covering all the dangling components with a heat-shrinking tube. After checking that everything works, I\u0026rsquo;ve zip-tied the receiver to the bunch of cables on the back of my PC and used it this way until moving to another city. I still have the device, and this is how it looks nowadays:\nThat\u0026rsquo;s how my desire to play some games motivated me to build something new!\nLinks  Project\u0026rsquo;s repo on GitHub ","date":"2021-02-25","permalink":"https://agarmash.com/posts/xbox-360-controller-receiver/","tags":["Xbox","AVR"],"title":"Building a Wireless Receiver for Xbox 360 Controllers From a Broken Xbox 360 Console"},{"content":"When the whole world was switching to streaming services, I bought an iPod Classic 5.5th generation. An independent device with locally stored music in lossless quality and decent audio codec was, and still is quite appealing for me. And as for me, its design is everlasting, a 14 y/o device still feels great and gets a lot of attention.\nThe only drawback was storage capacity - mine one had a 30 GB HDD, and although it was possible to find a unit with 80 gigs, it also wouldn\u0026rsquo;t be sufficient. Another option was to get a 6/7 generation one with 160 GB HDD, but I wanted to stay with the 5.5th gen unit.\nHardware mod 5th generation of iPods uses 1.8\u0026quot; ZIF HDD, which has an IDE interface with a different shaped connector. There is a number of available replacements:\n SD or CompactFlash adapter with the corresponding memory card — both adapter and large memory card are pricey, but among modding scene, it was the most popular option; 1.8\u0026quot; SSD with ZIF connector — quite a niche thing, which also makes it rather expensive; mSATA SSD with the adapter to ZIF — the least popular option for modding an iPod, but compared to the other options, was the best bang for the buck.  The last option was the most compelling for me, so I ordered an mSATA to ZIF adapter based on JM20330 chip (you can find it on eBay searching for \u0026ldquo;zif msata\u0026rdquo;) and a 250 GB Samsung 850 EVO mSATA SSD (its predecessor, 840 EVO had one of the greatest power characteristics, so it was a good choice). Also, I ordered some generic mSATA to regular SATA adapter, which unexpectedly played a great role in the whole project.\n Fun fact: 5th generation of iPod has 32 or 64 MB of SDRAM memory (depending on stock HDD capacity), while the ordered SSD has 512 MB of LPDDR3.\n When all the parts were delivered, at first I took the spare back cover and the main chassis from another dead iPod and put the mSATA-ZIF adapter between them. As you can see, the clearance was quite tight, there was less than a millimeter for adhesive and isolation.\nAt first, I thought of getting a back cover from a 60/80 GB unit, which is thicker, but I wanted to keep an old thin one. Also, when the SSD was plugged into the adapter, there was a noticeable gap between boards, which was quite a waste of space.\nThen I took a look at the SATA-mSATA adapter and noticed that it had a connector with the same footprint, but was a bit shorter.\nStacking boards together showed that the connectors\u0026rsquo; height difference was very similar to the size of the gap between SSD and mSATA-ZIF adapter.\nDelighted with this coincidence, I took my Rose\u0026rsquo;s metal and hot air soldering station, swapped the connectors, and filed down mounting standoffs to the correct height.\nAfter doing that, the SSD was flush with the mSATA-ZIF adapter board.\nSo I put a piece of isolation between the boards, plugged the SSD into the adapter, and tightened the mounting screws.\nWhen I put the resulting sandwich between spare iPod\u0026rsquo;s case parts, there were almost 2 millimeters of clearance, which was more than enough for securing the new components in place.\nAfter that, I put a layer of isolation to the back cover, added another piece of isolation to the backside of the adaptor board, plugged the ZIF flex cable to the adapter, secured it on the chassis with double-sided tape, and added stripes of packaging material to fill the void space.\nI wanted my iPod to be formatted in FAT32, so I had to use iTunes on Windows PC. After connecting an iPod I tried to restore it with iTunes, but the process was aborted with an error. After some troubleshooting, I figured out that the problem was in the NTFS partition on the SSD, which I created earlier to test the drive. I formatted it externally in FAT32, put back into the iPod and this time was able to restore it with iTunes.\nThe device was working and this could be the end of the story, but I decided to install Rockbox.\nRockbox After the trivial process of installing the custom firmware with Rockbox Utility and rebooting the iPod, I was greeted with the ATA error: -11. At the same time, stock firmware was still working fine. After some googling, I found a thread on Rockbox Forums, where the problem was investigated by the development team and solved by the user beyondwind. He also started a thread on Head-Fi Forums, where he posted some additional information. Unfortunately, at the moment of doing the mod, his website was down. Although it was possible to take a glance at it with help of Wayback Machine, almost all the content was unavailable. All, except the file ipod5g_msata_mod.patch, which undoubtedly was the most important. Also, it was saved on GitHub Gist by one of the users at Rockbox Forums.\nSo, with the patch in my possession, it was possible to build a patched firmware myself. Fortunately, Rockbox Wiki has a detailed guide for building firmware from scratch. The steps for doing so are well described, but I have some notes to make.\n1. Getting the source After cloning the repository, you can already apply the patch. It can be done with a bash command patch -p1 \u0026lt; path_to_file. Important notice about the patch file — the initial version had some changes for the plugin test_disk.c and included it in the regular build. The plugin code was highly modified since then and this part of the patch wasn\u0026rsquo;t applicable anymore, so I made the patch file without the mentioned pieces.\n2. Building a cross-compiler Automatic build works fine, but there are 3 caveats:\n I had a lot of difficulties building it on macOS Catalina. After 2 evenings of figuring out the origins of an endless stream of errors, I fired up a VM with Ubuntu 20.04.1 and was able to build the cross-compiler from one of the first tries. Although, a few years ago, when I built it for the first time, I was able to do it without a headache on macOS Sierra; The master branch sometimes can be broken. If you have difficulties with building, try checking out a bit earlier commit. For example, this one worked fine when I was building on Ubuntu; Make sure that all the dependencies listed on the wiki page are installed — initially, I have issues because of lacking texinfo.  3. Building Rockbox Fortunately, there were no issues here!\nIf everything was done correctly, after copying the freshly built .rockbox directory to the iPod it should just work. Finally, it\u0026rsquo;s time to copy some tunes and listen to them on your modded device!\nAnd also, there\u0026rsquo;s a patched build if you need it but don\u0026rsquo;t want to deal with patching and building.\nAfterword I accomplished this mod in January 2018 and was using the device almost every day since then. Later, I had to replace a battery because the old one dies of old age, but even with the old battery, there were no issues. Battery life is great, access time is instantaneous, and the weight loss is quite perceptible (an old HDD weight is close to the weight of the rest of the iPod). I\u0026rsquo;d recommend doing it to everyone who wants to give a second life to this classic device!\nFiles  ipod5g_msata_mod.patch — initial patch file by beyondwind; ipod5g_msata_mod_wo_plugin.patch — modified patch with removed changes for test_disk.c plugin, prefered for using; rockbox_msata_mod.zip — patched build from this commit. ","date":"2020-10-15","permalink":"https://agarmash.com/posts/ipod-classic-ssd/","tags":["iPod","SSD","Rockbox"],"title":"A Journey of Putting an SSD Into an iPod Classic With Rockbox"},{"content":" Initially, I wrote this article for Distillery Tech Blog back in 2018. I decided to copy it here for the further preservation.\n Nowadays, everyone values privacy and security. That’s why it wasn’t surprising when, recently, we needed to use an encryption library on one of the projects.\nFor the project in question, the decision was made to use libsignal. Originally developed for Signal Private Messenger, libsignal has a good reputation among security specialists.\nUsing libsignal At the end of July 2018, there were implementations of libsignal in C, Java, and JavaScript. There was also an implementation in Objective-C called SignalProtocolKit, but at that time it had already been deprecated.\nOur goal was to use the library in an iOS app written in Swift. To keep everything up to date, we had to use the one written in C, for which the source code is stored here. Lucky for us, Swift can interact with C code very smoothly, at minimum because some of Apple’s low-level libraries are written in C. The tricky part was to add the library to the project correctly.\nCreating a module.map After a bit of research, I figured out that I could simply add the library’s source code to the project and create a module.map file to specify which headers of the library I wanted to expose (for more detail, check out this blog). libsignal contains lots of header files, but if I want to use it in a regular C project, I only have to include the one called signal_protocol.h. Since signal_protocol.h includes the other headers it depends on, just as every other header file does, we can be sure that all the files are included. Accordingly, I made a module.map file with the following contents:\nmodule SignalProtocol [system] { header “src/signal_protocol.h” export * }  Then, I put it into the folder with the library sources, added it to the project, and started to test.\nXcode allowed to import this module and to use some of the library functions, but some of the library components were missing. For example, I was unable to use the signal_context data type which is defined in signal_protocol_internal.h.\nAt that moment it became obvious that Xcode doesn’t properly include nested headers. So I decided to try including all the headers from libsignal in my module.map file. (It’s redundant to put the updated module.map here, as it just includes every *.h file similar to the file above.)\nAfter I did this and tried to build to build the project, I got a lot of errors related to some of the header files from libsignal. When I took a look at them, I realized that there were some header files that were not actual headers. Instead, they store some constant values and are used as follows:\nstatic const fe sqrtm1 = { #include “sqrtm1.h” } ;  As of the end of July 2018, the following files were used that way:\nsqrtm1.h ge_sub.h pow225521.h ge_add.h d2.h ge_madd.h ge_msub.h pow22523.h ge_p2_dbl.h d.h base2.h base.h  Finally, after excluding these files from my module.map, I was able to build the project and use all the parts of libsignal.\nWas it a victory? A moderate one, I guess. Adding the sources of a third-party library directly to the project didn’t seem quite right, so we decided to wrap libsignal in the Cocoa Touch Framework.\nWrapping It in the Cocoa Touch Framework At first, after all the previous difficulties, I thought this part would be easy. Unfortunately, I was proven wrong the exact moment I opened the Build Settings of our freshly created project framework and couldn’t find the “Swift Compiler — Search Paths” section.\nWhat followed were several attempts to include the libsignal sources in the framework. I will only describe the one that was successful.\nTo wrap a С library in the Cocoa Touch Framework (using the example of libsignal), follow these steps:\n1. Create a New Project Create a new project. For its type, choose “Cocoa Touch Framework.”\n2. Add Source Files Add the source files of the library to the project.\n3. Select Headers to Expose Go to the project file and select your target framework. Open the “Build Phases” tab. Here, in the “Headers” section, all the headers from the library should appear. Decide which ones to expose by dragging them to the “Public” list. In the case of libsignal, I decided to make all the headers public.\nBy the way, here you should have all the *.h files, even those that just store constants.\n4. Import Headers Now, since all the headers have been added to your project, you have to import them into the main header of the framework, which should be called [your framework name].h and placed in the root directory of the framework. Add the following line for every actual header, omitting those that just store constants:\n#import “protocol.h”  Note that, since we added all headers to the project file, we only have to use filename without specifying the whole path to the file in the project. It works this way because all of the headers are copied inside the framework bundle, and all paths inside the project become invalid.\nVoilà! You should have a fully functioning framework.\nDo note, however, that at the moment, it has one major disadvantage: It keeps a particular version of libsignal and doesn’t allow you to update it from its GitHub repository. That issue, however, is outside the scope of this article.\n","date":"2020-09-30","permalink":"https://agarmash.com/posts/c-library-in-swift/","tags":["C","Swift"],"title":"How to Integrate a C Library into an iOS App Written in Swift"}]