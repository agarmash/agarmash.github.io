[{"content":"When the whole world was switching to streaming services, I bought an iPod Classic 5.5th generation. An independent device with locally stored music in lossless quality and decent audio codec was, and still is quite appealing for me. And as for me, its design is everlasting, a 14 y/o device still feels great and gets a lot of attention.\nThe only drawback was storage capacity - mine one had a 30 GB HDD, and although it was possible to find a unit with 80 gigs, it also wouldn\u0026rsquo;t be sufficient. Another option was to get a 6/7 generation one with 160 GB HDD, but I wanted to stay with the 5.5th gen unit.\nHardware mod 5th generation of iPods uses 1.8\u0026rdquo; ZIF HDD, which has an IDE interface with a different shaped connector. There is a number of available replacements:\n SD or CompactFlash adapter with the corresponding memory card — both adapter and large memory card are pricey, but among modding scene, it was the most popular option; 1.8\u0026rdquo; SSD with ZIF connector — quite a niche thing, which also makes it rather expensive; mSATA SSD with the adapter to ZIF — the least popular option for modding an iPod, but compared to the other options, was the best bang for the buck.  The last option was the most compelling for me, so I ordered an mSATA to ZIF adapter based on JM20330 chip (you can find it on eBay searching for \u0026ldquo;zif msata\u0026rdquo;) and a 250 GB Samsung 850 EVO mSATA SSD (its predecessor, 840 EVO had one of the greatest power characteristics, so it was a good choice). Also, I ordered some generic mSATA to regular SATA adapter, which unexpectedly played a great role in the whole project.\n Fun fact: 5th generation of iPod has 32 or 64 MB of SDRAM memory (depending on stock HDD capacity), while the ordered SSD has 512 MB of LPDDR3.\n When all the parts were delivered, at first I took the spare back cover and the main chassis from another dead iPod and put the mSATA-ZIF adapter between them. As you can see, the clearance was quite tight, there was less than a millimeter for adhesive and isolation.\nAt first, I thought of getting a back cover from a 60/80 GB unit, which is thicker, but I wanted to keep an old thin one. Also, when the SSD was plugged into the adapter, there was a noticeable gap between boards, which was quite a waste of space.\nThen I took a look at the SATA-mSATA adapter and noticed that it had a connector with the same footprint, but was a bit shorter.\nStacking boards together showed that the connectors\u0026rsquo; height difference was very similar to the size of the gap between SSD and mSATA-ZIF adapter.\nDelighted with this coincidence, I took my Rose\u0026rsquo;s metal and hot air soldering station, swapped the connectors, and filed down mounting standoffs to the correct height.\nAfter doing that, the SSD was flush with the mSATA-ZIF adapter board.\nSo I put a piece of isolation between the boards, plugged the SSD into the adapter, and tightened the mounting screws.\nWhen I put the resulting sandwich between spare iPod\u0026rsquo;s case parts, there were almost 2 millimeters of clearance, which was more than enough for securing the new components in place.\nAfter that, I put a layer of isolation to the back cover, added another piece of isolation to the backside of the adaptor board, plugged the ZIF flex cable to the adapter, secured it on the chassis with double-sided tape, and added stripes of packaging material to fill the void space.\nI wanted my iPod to be formatted in FAT32, so I had to use iTunes on Windows PC. After connecting an iPod I tried to restore it with iTunes, but the process was aborted with an error. After some troubleshooting, I figured out that the problem was in the NTFS partition on the SSD, which I created earlier to test the drive. I formatted it externally in FAT32, put back into the iPod and this time was able to restore it with iTunes.\nThe device was working and this could be the end of the story, but I decided to install Rockbox.\nRockbox After the trivial process of installing the custom firmware with Rockbox Utility and rebooting the iPod, I was greeted with the ATA error: -11. At the same time, stock firmware was still working fine. After some googling, I found a thread on Rockbox Forums, where the problem was investigated by the development team and solved by the user beyondwind. He also started a thread on Head-Fi Forums, where he posted some additional information. Unfortunately, at the moment of doing the mod, his website was down. Although it was possible to take a glance at it with help of Wayback Machine, almost all the content was unavailable. All, except the file ipod5g_msata_mod.patch, which undoubtedly was the most important. Also, it was saved on GitHub Gist by one of the users at Rockbox Forums.\nSo, with the patch in my possession, it was possible to build a patched firmware myself. Fortunately, Rockbox Wiki has a detailed guide for building firmware from scratch. The steps for doing so are well described, but I have some notes to make.\n1. Getting the source After cloning the repository, you can already apply the patch. It can be done with a bash command patch -p1 \u0026lt; path_to_file. Important notice about the patch file — the initial version had some changes for the plugin test_disk.c and included it in the regular build. The plugin code was highly modified since then and this part of the patch wasn\u0026rsquo;t applicable anymore, so I made the patch file without the mentioned pieces.\n2. Building a cross-compiler Automatic build works fine, but there are 3 caveats:\n I had a lot of difficulties building it on macOS Catalina. After 2 evenings of figuring out the origins of an endless stream of errors, I fired up a VM with Ubuntu 20.04.1 and was able to build the cross-compiler from one of the first tries. Although, a few years ago, when I built it for the first time, I was able to do it without a headache on macOS Sierra; The master branch sometimes can be broken. If you have difficulties with building, try checking out a bit earlier commit. For example, this one worked fine when I was building on Ubuntu; Make sure that all the dependencies listed on the wiki page are installed — initially, I have issues because of lacking texinfo.  3. Building Rockbox Fortunately, there were no issues here!\nIf everything was done correctly, after copying the freshly built .rockbox directory to the iPod it should just work. Finally, it\u0026rsquo;s time to copy some tunes and listen to them on your modded device!\nAnd also, there\u0026rsquo;s a patched build if you need it but don\u0026rsquo;t want to deal with patching and building.\nAfterword I accomplished this mod in January 2018 and was using the device almost every day since then. Later, I had to replace a battery because the old one dies of old age, but even with the old battery, there were no issues. Battery life is great, access time is instantaneous, and the weight loss is quite perceptible (an old HDD weight is close to the weight of the rest of the iPod). I\u0026rsquo;d recommend doing it to everyone who wants to give a second life to this classic device!\nFiles  ipod5g_msata_mod.patch — initial patch file by beyondwind; ipod5g_msata_mod_wo_plugin.patch — modified patch with removed changes for test_disk.c plugin, prefered for using; rockbox_msata_mod.zip — patched build from this commit. ","date":"2020-10-15","permalink":"https://agarmash.com/posts/ipod-classic-ssd/","tags":["ipod","ssd","rockbox"],"title":"A journey of putting an SSD into an iPod Classic with Rockbox"},{"content":" Initially, I wrote this article for Distillery Tech Blog back in 2018. I decided to copy it here for the further preservation.\n Nowadays, everyone values privacy and security. That’s why it wasn’t surprising when, recently, we needed to use an encryption library on one of the projects.\nFor the project in question, the decision was made to use libsignal. Originally developed for Signal Private Messenger, libsignal has a good reputation among security specialists.\nUsing libsignal At the end of July 2018, there were implementations of libsignal in C, Java, and JavaScript. There was also an implementation in Objective-C called SignalProtocolKit, but at that time it had already been deprecated.\nOur goal was to use the library in an iOS app written in Swift. To keep everything up to date, we had to use the one written in C, for which the source code is stored here. Lucky for us, Swift can interact with C code very smoothly, at minimum because some of Apple’s low-level libraries are written in C. The tricky part was to add the library to the project correctly.\nCreating a module.map After a bit of research, I figured out that I could simply add the library’s source code to the project and create a module.map file to specify which headers of the library I wanted to expose (for more detail, check out this blog). libsignal contains lots of header files, but if I want to use it in a regular C project, I only have to include the one called signal_protocol.h. Since signal_protocol.h includes the other headers it depends on, just as every other header file does, we can be sure that all the files are included. Accordingly, I made a module.map file with the following contents:\nmodule SignalProtocol [system] { header “src/signal_protocol.h” export * }  Then, I put it into the folder with the library sources, added it to the project, and started to test.\nXcode allowed to import this module and to use some of the library functions, but some of the library components were missing. For example, I was unable to use the signal_context data type which is defined in signal_protocol_internal.h.\nAt that moment it became obvious that Xcode doesn’t properly include nested headers. So I decided to try including all the headers from libsignal in my module.map file. (It’s redundant to put the updated module.map here, as it just includes every *.h file similar to the file above.)\nAfter I did this and tried to build to build the project, I got a lot of errors related to some of the header files from libsignal. When I took a look at them, I realized that there were some header files that were not actual headers. Instead, they store some constant values and are used as follows:\nstatic const fe sqrtm1 = { #include “sqrtm1.h” } ;  As of the end of July 2018, the following files were used that way:\nsqrtm1.h ge_sub.h pow225521.h ge_add.h d2.h ge_madd.h ge_msub.h pow22523.h ge_p2_dbl.h d.h base2.h base.h  Finally, after excluding these files from my module.map, I was able to build the project and use all the parts of libsignal.\nWas it a victory? A moderate one, I guess. Adding the sources of a third-party library directly to the project didn’t seem quite right, so we decided to wrap libsignal in the Cocoa Touch Framework.\nWrapping It in the Cocoa Touch Framework At first, after all the previous difficulties, I thought this part would be easy. Unfortunately, I was proven wrong the exact moment I opened the Build Settings of our freshly created project framework and couldn’t find the “Swift Compiler — Search Paths” section.\nWhat followed were several attempts to include the libsignal sources in the framework. I will only describe the one that was successful.\nTo wrap a С library in the Cocoa Touch Framework (using the example of libsignal), follow these steps:\n1. Create a New Project Create a new project. For its type, choose “Cocoa Touch Framework.”\n2. Add Source Files Add the source files of the library to the project.\n3. Select Headers to Expose Go to the project file and select your target framework. Open the “Build Phases” tab. Here, in the “Headers” section, all the headers from the library should appear. Decide which ones to expose by dragging them to the “Public” list. In the case of libsignal, I decided to make all the headers public.\nBy the way, here you should have all the *.h files, even those that just store constants.\n4. Import Headers Now, since all the headers have been added to your project, you have to import them into the main header of the framework, which should be called [your framework name].h and placed in the root directory of the framework. Add the following line for every actual header, omitting those that just store constants:\n#import “protocol.h”  Note that, since we added all headers to the project file, we only have to use filename without specifying the whole path to the file in the project. It works this way because all of the headers are copied inside the framework bundle, and all paths inside the project become invalid.\nVoilà! You should have a fully functioning framework.\nDo note, however, that at the moment, it has one major disadvantage: It keeps a particular version of libsignal and doesn’t allow you to update it from its GitHub repository. That issue, however, is outside the scope of this article.\n","date":"2020-09-30","permalink":"https://agarmash.com/posts/c-library-in-swift/","tags":["c","swift"],"title":"How to Integrate a C Library into an iOS App Written in Swift"}]