<!DOCTYPE html>
<html lang="en">

<head>
    
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
<meta name="HandheldFriendly" content="True" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
<meta name="generator" content="Hugo 0.101.0" />



<title>Exploiting Xbox Game Frogger Beyond to Execute Arbitrary Unsigned Code - Artem Garmash</title>


<meta name="author" content="Artem Garmash" />



<meta name="keywords" content="Xbox, Exploitation" />

<meta property="og:title" content="Exploiting Xbox Game Frogger Beyond to Execute Arbitrary Unsigned Code" />
<meta property="og:description" content="The Original Xbox was a total disaster from a security point of view. It has been fully cracked relatively quickly, so it became possible to modify your system to disable the security checks and run the unsigned code: Linux, homebrew, game backups - you name it.
For making that possible for the end user, 2 modding methods have been created:

Hardmod - requires soldering a modchip to the mainboard that contains the modified BIOS with security checks disabled and overrides the built-in flash memory. This is the most reliable and fool-proof method, but it requires modifying the hardware;
Softmod - requires triggering a chain of exploits in software. Usually, a commercially available videogame with exploitable vulnerabilities in the savefile loading code is used as an entry point. Less reliable since the console can be bricked by doing something wrong (however, hardmod would fix it in any case), but doesn&rsquo;t require any soldering iron involvement.

Even today, the softmod is a preferred method for a lot of people, so we&rsquo;re going to take a look at how some parts of the softmod work, and create a brand new savefile exploit." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://agarmash.com/posts/xbox-frogger-beyond-exploit/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-03T20:20:19+01:00" />
<meta property="article:modified_time" content="2022-10-03T20:20:19+01:00" />


<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Exploiting Xbox Game Frogger Beyond to Execute Arbitrary Unsigned Code"/>
<meta name="twitter:description" content="The Original Xbox was a total disaster from a security point of view. It has been fully cracked relatively quickly, so it became possible to modify your system to disable the security checks and run the unsigned code: Linux, homebrew, game backups - you name it.
For making that possible for the end user, 2 modding methods have been created:

Hardmod - requires soldering a modchip to the mainboard that contains the modified BIOS with security checks disabled and overrides the built-in flash memory. This is the most reliable and fool-proof method, but it requires modifying the hardware;
Softmod - requires triggering a chain of exploits in software. Usually, a commercially available videogame with exploitable vulnerabilities in the savefile loading code is used as an entry point. Less reliable since the console can be bricked by doing something wrong (however, hardmod would fix it in any case), but doesn&rsquo;t require any soldering iron involvement.

Even today, the softmod is a preferred method for a lot of people, so we&rsquo;re going to take a look at how some parts of the softmod work, and create a brand new savefile exploit."/>





<link rel="stylesheet" href="https://agarmash.com/assets/css/fuji.min.css" />





<script>
    window.dataLayer = window.dataLayer || [];

    function gtag() {
        dataLayer.push(arguments);
    }
    gtag('js', new Date());
    gtag('config', 'UA-179143853-1');
</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-179143853-1"></script>


</head>

<body data-theme="auto">
    <script data-cfasync="false">
  
  var fujiThemeData = localStorage.getItem('fuji_data-theme');
  
  if (!fujiThemeData) {
    localStorage.setItem('fuji_data-theme', 'auto');
  } else {
    
    if (fujiThemeData !== 'auto') {
      document.body.setAttribute('data-theme', fujiThemeData === 'dark' ? 'dark' : 'light');
    }
  }
</script>

    <header>
    <div class="container-lg clearfix">
        <div class="col-12 header">
            <a class="title-main" href="https://agarmash.com">Artem Garmash</a>
            
            <span class="title-sub">Software developer, hardware enthusiast, mountain bike rider, musichead</span>
            
        </div>
    </div>
</header>

    <main>
        <div class="container-lg clearfix">
            
            <div class="col-12 col-md-9 float-left content">
                
<article>
    
    <h2 class="post-item post-title">
        <a href="https://agarmash.com/posts/xbox-frogger-beyond-exploit/">Exploiting Xbox Game Frogger Beyond to Execute Arbitrary Unsigned Code</a>
    </h2>
    
    <div class="post-item post-meta">
        <span><i class="iconfont icon-today-sharp"></i>&nbsp;2022-10-03</span><span><i class="iconfont icon-time-sharp"></i>&nbsp;20 minutes</span><span><i class="iconfont icon-pricetags-sharp"></i>&nbsp;<a href="/tags/xbox">Xbox</a>&nbsp;<a href="/tags/exploitation">Exploitation</a>&nbsp;</span>

    </div>
    
    
    
    <div class="post-content markdown-body">
        <p>The Original Xbox was a <a href="https://xboxdevwiki.net/17_Mistakes_Microsoft_Made_in_the_Xbox_Security_System" target="_blank">total disaster from a security point of view</a>. It has been fully cracked relatively quickly, so it became possible to modify your system to disable the security checks and run the unsigned code: Linux, homebrew, game backups - you name it.</p>
<p>For making that possible for the end user, 2 modding methods have been created:</p>
<ul>
<li>Hardmod - requires soldering a modchip to the mainboard that contains the modified BIOS with security checks disabled and overrides the built-in flash memory. This is the most reliable and fool-proof method, but it requires modifying the hardware;</li>
<li>Softmod - requires triggering a chain of exploits in software. Usually, a commercially available videogame with exploitable vulnerabilities in the savefile loading code is used as an entry point. Less reliable since the console can be bricked by doing something wrong (however, hardmod would fix it in any case), but doesn&rsquo;t require any soldering iron involvement.</li>
</ul>
<p>Even today, the softmod is a preferred method for a lot of people, so we&rsquo;re going to take a look at how some parts of the softmod work, and create a brand new savefile exploit.</p>
<h2 id="attack-surface">Attack surface</h2>
<p>The Xbox kernel is based on Windows 2000. However, a lot of the features have been stripped, including multitasking, so only a single executable is running at the time. Moreover, every executable is running with kernel privileges, to squeeze a few extra bits of performance. On top of that, The system is based on the Intel Pentium 3 CPU, which doesn&rsquo;t have an NX-bit feature, so all the memory pages are executable. This makes the process quite straightforward - once we hijacked the program execution, we ultimately have control over the whole system.</p>
<p>Vanilla Xbox can ultimately run one of the following pieces of software:</p>
<ul>
<li>Dashboard - starts if there&rsquo;s no game disc present in the optical drive. Has its share of vulnerabilities, however, none of them is possible to trigger from the unmodified state;</li>
<li>Videogame - loaded from a DVD disc with lots of copy protection measures, contains an RSA signed executable (as well as every other official executable), can load and store savefiles from/to built-in HDD or a memory card.</li>
</ul>
<p>Savefiles are of particular interest to us:</p>
<ul>
<li>Often they store string values (like the player&rsquo;s name) in form of null-terminated C strings. If the game doesn&rsquo;t validate the length of the string, there&rsquo;s a potential buffer overflow we can exploit;</li>
<li>Savefiles are the only adequate option to provide the initial shellcode that will be executed after hijacking a program control flow.</li>
</ul>
<p>Microsoft clearly didn&rsquo;t want anyone to tamper with the savefiles, so they obliged the game developers to incorporate a digital signature into every savefile and to check it on loading. They even provided a convenient API for doing that. However, after the system has been cracked, people discovered that the algorithm for generating signature looks like that:</p>
<pre><code>derived_key = HMAC(game_key, xbox_key, SHA1)
signature = HMAC(derived_key, savefile_data, SHA1)
</code></pre>
<p>The aforementioned <code>xbox_key</code> is the key that is stored in the system software and is unique for every console, the <code>game_key</code> is the key that is stored in the game executable&rsquo;s header and is unique to every game. It&rsquo;s also possible to tie the savefile to the particular console by adding the per-console key to the mix. In Microsoft terminology it&rsquo;s called a &ldquo;non-roamable signature&rdquo;, you can learn more about it <a href="https://agarmash.com/posts/xbox-black-reverse-engineering/">here in my other post</a>.</p>
<p>This gives us enough information to start exploring games for vulnerabilities. However, there are some more topics to cover first.</p>
<h2 id="existing-savefile-exploits">Existing savefile exploits</h2>
<p>It shouldn&rsquo;t be a surprise that this kind of exploit has been implemented multiple times. Let&rsquo;s take a look at the <a href="https://github.com/Rocky5/Xbox-Softmodding-Tool/tree/master/Other/Game%20Saves/Extracted" target="_blank">existing ones</a>:</p>
<ul>
<li>007: Agent Under Fire (March 2003) - The first one released. <a href="https://web.archive.org/web/20030411132938/http://www.xboxhacker.net:80/forums/index.php?act=ST&amp;f=12&amp;t=10520" target="_blank">Created</a> by habibi_xbox (David Jilli). Shellcode is encrypted and the decryption code is heavily obfuscated. The decryptor can be found <a href="https://github.com/agarmash/FroggerBeyondExploit/blob/master/extras/007_exploit_decryptor.c" target="_blank">here</a>. Technical breakdown is available <a href="https://web.archive.org/web/20031003093240/http://xbox-linux.sourceforge.net:80/docs/007analysis.html" target="_blank">here</a>;</li>
<li>MechAssault (June 2003) - Released soon after the 007 exploit. Shellcode is similar to the 007 and is stored as plaintext;</li>
<li>Splinter Cell (December 2003) - released at the 20th Chaos Communication Conference (20C3) by Andrew &ldquo;bunnie&rdquo; Huang and Michael Steil of the Xbox-Linux project. Shellcode differs from the previous exploits (more about that later). It is also encrypted with a simple XOR cipher, most likely to remove the zero bytes from the binary to copy it a part of the string. The decryptor can be found <a href="https://github.com/agarmash/FroggerBeyondExploit/blob/master/extras/splinter_cell_exploit_decryptor.c" target="_blank">here</a>;</li>
<li>Tony Hawk 4 (April 2017) - <a href="https://www.xbmc4xbox.org.uk/forum/viewtopic.php?t=7310" target="_blank">created</a> by Grimdoomer. The shellcode looks similar to the decrypted one from the Splinter cell.</li>
<li>Metal Arms (January 2022) - <a href="https://discord.com/channels/428359196719972353/428399682239332354/930855324078981200" target="_blank">created</a> by <a href="https://github.com/dj0wns" target="_blank">dj0wns (Derek Jones)</a>. The first half of the shellcode seems to be borrowed from the 007 exploit. Uses some format string vulnerabilities as well to achieve code execution.</li>
</ul>
<p>Now, there&rsquo;s an interesting bit. During his <a href="https://youtu.be/82vf0JQS1Sk?t=3379" target="_blank">talk at the 22C3</a>, Michael Steil mentioned Frogger Beyond among the rest of the exploited games. However, this is the only mention of this game, and there&rsquo;s no exploit in public for it. And since I was already playing with the Xbox internals, I decided to figure out how can the Frogger be exploited.</p>
<h2 id="prerequisite-debug-hardware">Prerequisite: debug hardware</h2>
<p>It would be quite hard to learn about the program internals and to craft an exploit without a debugger. Fortunately for us, it&rsquo;s possible to convert a retail Xbox into a debug kit by adding the <a href="https://github.com/XboxDev/serial-usb-adapter" target="_blank">SuperIO board</a> to get the serial port connectivity and by running the debug system software. After doing that, you can debug the Xbox with WinDbg kernel debugger. <a href="http://windbg.info/doc/1-common-cmds.html" target="_blank">Here&rsquo;s a good referense of the WinDbg commands</a>.</p>
<p>Debug conversion is out of the scope of this article, but this is how my Xbox ended up hardware-wise:</p>
<p><img class="img-zoomable" src="/xbox-frogger-beyond-exploit/hw1.jpg" alt="1" />

<img class="img-zoomable" src="/xbox-frogger-beyond-exploit/hw2.jpg" alt="1" />

<img class="img-zoomable" src="/xbox-frogger-beyond-exploit/hw3.jpg" alt="1" />

<img class="img-zoomable" src="/xbox-frogger-beyond-exploit/hw4.jpg" alt="1" />
</p>
<h2 id="examining-the-game-for-a-possible-overflow">Examining the game for a possible overflow</h2>
<p>Time to get our hands dirty.<br>
First of all, let&rsquo;s boot the game and play a bit until the game allows us to save the progress. After saving the game, transferring the savefile from the console, and opening it with a hex editor, we can see the following:</p>
<p><img class="img-zoomable" src="/xbox-frogger-beyond-exploit/original_savefile.png" alt="1" />
</p>
<p>The file starts with a magic byte <code>0x01</code>, after that comes the player name if the form of a null-terminated string, and after that there are some sparse bits of data. The rest is just zeros, and the last 20 bytes are the signature.</p>
<p>Now the obvious thing for us to do is to fuzz the string. We extend the string with a long non-null pattern of bytes, sign the savefile, copy it to the console, and let the game try to load it:</p>
<p><img class="img-zoomable" src="/xbox-frogger-beyond-exploit/fuzzed_string.png" alt="1" />
</p>
<p>Unsurprisingly, the game crashes with <code>Access violation: writing to location 0x07070723</code>, which indicates that we probably overwrote some pointer in the local stack frame which got used before returning from the function:</p>
<p><img class="img-zoomable" src="/xbox-frogger-beyond-exploit/access_violation.png" alt="1" />
</p>
<p>By playing with the long string contents I figured out that the pointer is overwritten with the bytes at the offset <code>0x159-0x15C</code> in the savefile.<br>
The debugger also shows us the call stack during the exception, the top entries of which are <code>0xd68ef</code> and <code>0xdd51e</code> (and the rest is a corrupted stack):</p>
<p><img class="img-zoomable" src="/xbox-frogger-beyond-exploit/crash_call_stack.png" alt="1" />
</p>
<p>Another thing we can do is to search the RAM for the loaded savefiles. Fortunately for us, the game loads the first savefile to the memory address <code>0x00429bd2</code>:</p>
<p><img class="img-zoomable" src="/xbox-frogger-beyond-exploit/savefile_in_memory1.png" alt="1" />

<img class="img-zoomable" src="/xbox-frogger-beyond-exploit/savefile_in_memory2.png" alt="1" />
</p>
<p>Conveniently, the address remains the save between the reboots, so we don&rsquo;t need to copy our payload as part of the string, it&rsquo;s already waiting for us in the memory.</p>
<h2 id="examining-the-executable-internals">Examining the executable internals</h2>
<p>Now, let&rsquo;s fire up Ghidra and take a look at what&rsquo;s going on in the game executable by the addresses from the call stack.</p>
<p>First comes the function containing the offset <code>0xdd51e</code>. In short, there&rsquo;s a big function for handling a lot of different stuff related to loading the savefiles of the game. Let&rsquo;s skip the Assembly and go straight to the decompilation of the interesting part. The instruction at the aforementioned offset is the next one after the <code>CALL</code> to the <code>my_presentAlert</code> function. Oh, by the way, all the symbols are stripped from the executable, what you see is what I was able to recover:</p>
<p><img class="img-zoomable" src="/xbox-frogger-beyond-exploit/decompile1.png" alt="1" />
</p>
<p>The interesting lines are 344-346. Here we can see that the string is formatted and copied to the <code>local_170</code> buffer, and the function <code>my_prepareAlert</code> is being called with the pointer to the <code>local_170</code> as one of its parameters.</p>
<p>After examining the executable with Ghidra and the memory of the running game with WinDbg, we can recreate the interesting part of the stack frame of this function:</p>
<p><img class="img-zoomable" src="/xbox-frogger-beyond-exploit/stack.png" alt="1" />
</p>
<p>As you can see, there is a <code>local_170</code> buffer that we can overflow, some other local variables we&rsquo;re not interested in, a <code>this_</code> pointer to an instance of some game class, saved EBP value, and the return address.</p>
<p>Now let&rsquo;s take a look at the function containing the offset <code>0xd68ef</code>. It contains the logic related to presenting the on-screen alert. In our case, it gets called with the following parameters:</p>
<ul>
<li><code>this</code>: pointer to memory</li>
<li><code>selector</code>: 2</li>
<li><code>message</code>: pointer to memory</li>
<li><code>unknown1</code>: 0</li>
<li><code>unknown2</code>: 0</li>
</ul>
<p>This is what the result of its decompilation looks like:</p>
<p><img class="img-zoomable" src="/xbox-frogger-beyond-exploit/decompile2.png" alt="1" />
</p>
<p>The instruction at the aforementioned offset is represented by the line 6. It aligns perfectly with the &ldquo;Access violation&rdquo; exception - we corrupted the pointer and tried to write something to some invalid address.<br>
Since at this point we&rsquo;re not planning to return back to the running game, we can just overwrite <code>this_</code> pointer with some &ldquo;safe to write to&rdquo; address (e.g. a higher address in the stack, like <code>0xd014a9b0</code>) and check if the game &ldquo;survives&rdquo; until returning from the <code>dd51e</code> function. Running the game step-by-step in the debugger shows that it happily reaches the end of the function and tries to return to the address that we overwrote. Perfect.</p>
<p>Now it&rsquo;s time to take a step aside and think what code we want to execute after hijacking the execution flow, aka the shellcode.</p>
<h2 id="shellcode">Shellcode</h2>
<p>Generally, a shellcode should achieve 2 goals:</p>
<ul>
<li>Circumvent the RSA signature check of the executable;</li>
<li>Run the unsigned executable that is provided as part of the savefile package.</li>
</ul>
<p>To achieve that, shellcode does the following:</p>
<ul>
<li>Disables memory write protection:
<ul>
<li>Achieved by clearing out the Write Protect bit in the CR0 register. As the <a href="https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html" target="_blank">IntelÂ® 64 and IA-32 Architectures Software Developer Manual, Vol. 3A</a> describes it, &ldquo;when set, inhibits supervisor-level procedures from writing into read-only pages; when clear, allows supervisor-level procedures to write into read-only pages&rdquo;. Conveniently, we&rsquo;re already running in ring 0, so all the memory magically becomes writable!</li>
<li>another way to do that is kinda obscure. As Thrimbor <a href="https://discord.com/channels/428359196719972353/428399682239332354/1013545500026355724" target="_blank">said</a> <a href="/xbox-frogger-beyond-exploit/thrimbor_answer.png">(message screenshot)</a>, it looks like pathing the R/W bit of page table entries from the offset <code>0xc0200000</code>;</li>
</ul>
</li>
<li>Patches the RSA key. The original 007 exploit <a href="https://web.archive.org/web/20031003093240/http://xbox-linux.sourceforge.net:80/docs/007analysis.html" target="_blank">tried to limit the use of the exploit to Linux booting only</a>. Instead of disabling the signature check, the author decided to change the last 4 bytes of the public key. The resultant key is divisible by 3, which makes it easily factorable, which in turn allows us to retrieve the private key and sign our own executables. This pair of keys is called &ldquo;habibi&rdquo; after the nickname of the author of the original exploit habibi_xbox (David Jilli). There are multiple approaches to patching the key:
<ul>
<li>Search for the key in the kernel address space. That was the original method of doing that - the exploit does a linear search for the last for 4 bytes of the key in memory, and patches them once they are found;</li>
<li>Get the address of the kernel structure which holds the public key from the kernel exports table. After getting the address, we just patch the bytes at the known offset from the beginning of the structure;</li>
</ul>
</li>
<li>Launches the provided executable. It can also be done in several ways:
<ul>
<li>By calling the XAPI methods. First, the DVD drive should be unmapped from the &ldquo;D:&rdquo; drive and the partition containing the game saves should be mapped to <code>D:</code> instead. This is done since XAPI will refuse to launch an executable from the drive different from <code>D:</code>. It can be achieved by calling <code>IoDeleteSymbolicLink</code> and <code>IoCreateSymbolicLink</code> kernel functions respectively. After that, it&rsquo;s possible to run the <code>XLaunchNewImage</code> XAPI function to run the executable. The main downside of this method is that we need to know the offset of the statically linked XAPI inside the executable, which makes the exploit non-portable. Used by 007 and MechAssault exploits;</li>
<li>By calling the kernel methods directly. This is what the <code>XLaunchNewImage</code> XAPI function does under the hood. An example code can be found <a href="https://github.com/XboxDev/OpenXDK/blob/master/src/hal/xbox.c#L36" target="_blank">in the OpenXDK repository</a>. In contrast, this code is portable between the executables, and doesn&rsquo;t even require the target executable to be statically linked against XAPI. Achieved by:
<ul>
<li>Getting the address of the memory page containing <a href="https://xboxdevwiki.net/Kernel/LaunchDataPage" target="_blank"><code>LaunchDataPage</code></a> kernel structure;</li>
<li>Allocating the new memory page if the pointer is NULL by calling <a href="https://xboxdevwiki.net/Kernel/MmAllocateContiguousMemory" target="_blank"><code>MmAllocateContiguousMemory</code></a>;</li>
<li>Saving the pointer back in the kernel by calling <code>MmPersistContiguousMemory</code>;</li>
<li>Zeroing out the memory page and setting it up with the required parameters, including the path to the executable;</li>
<li>Calling <code>HalReturnToFirmware</code> with the parameter <code>ReturnFirmwareQuickReboot</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>In addition, exploits that disable memory write protection through the CR0 register are combining the write protection disabling and the key patching inside the critical section, <a href="https://lkml.iu.edu/hypermail/linux/kernel/9703.0/0060.html" target="_blank">achieved by temporarily disabling the CPU interrupts</a>. Some of the exploits also invalidate TLB and flush the CPU caches as a precaution.</p>
<p>The table below shows which exploit uses which of the described approaches:</p>
<table>
<thead>
<tr>
<th></th>
<th>007</th>
<th>MechAssault</th>
<th>Splinter Cell</th>
<th>Tony Hawk 4</th>
<th>MetalArms</th>
</tr>
</thead>
<tbody>
<tr>
<td>Disabling memory write protection</td>
<td>Page table patching</td>
<td>CR0</td>
<td>CR0</td>
<td>CR0</td>
<td>Page table patching</td>
</tr>
<tr>
<td>Public key patching</td>
<td>Search for the key</td>
<td>Known offset</td>
<td>Known offset</td>
<td>Known offset</td>
<td>Search for the key</td>
</tr>
<tr>
<td>Launching the executable</td>
<td>XAPI</td>
<td>XAPI</td>
<td>Kernel calls</td>
<td>Kernel calls</td>
<td>Kernel calls</td>
</tr>
<tr>
<td>Critical section</td>
<td>No</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>Invalidates TLB</td>
<td>No</td>
<td>Yes (twice)</td>
<td>Yes (twice)</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>Flushes CPU caches</td>
<td>No</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>
</tbody>
</table>
<h2 id="choosing-a-shellcode">Choosing a shellcode</h2>
<p>Well, there are plenty of options to choose from. We can construct our own shellcode using parts of the existing ones, or just adapt an existing shellcode to our purposes. However, it&rsquo;s not really convenient to do that.</p>
<p>Fortunately, we can take a slightly different route. There is a dashboard exploit called <a href="http://archiv.sega-dc.de/phoenix.maxconsole.net/docs/berternie.inc.htm" target="_blank">Bert &amp; Ernie</a> that exploits a vulnerability in the font loading code. I wasn&rsquo;t able to find the original exploit, but what I found instead is an <a href="https://github.com/Rocky5/Xbox-Softmodding-Tool/blob/master/App%20Sources/NKPatcher/Main%20NKP11/ernie.asm" target="_blank">offshoot of this exploit</a> as part of the NKPatcher 11 tool in Rocky5&rsquo;s softmod repository. It has all the pieces of the shellcode described above. More importantly, its Assembly source code is available. This basically makes it a DIY kit for our own exploit, especially since the code is portable due to the absence if the XAPI calls.</p>
<h2 id="returning-to-shellcode">Returning to shellcode</h2>
<p>Now since we have all the required bits, it&rsquo;s time for us to create an exploited savefile. We achieve that by doing the following:</p>
<ul>
<li>Fill the gap from the end of the profile name to the offset <code>0x158</code> with any non-zero values. The key is to not have a zero byte (C string terminator) until we overwrote all the interesting things on the stack;</li>
<li>Put the overwrite value of <code>this_</code> at the offset <code>0x159</code> of the savefile. As mentioned before, we&rsquo;re overwriting it with a higher address on the stack, <code>0xd014a9b0</code>;</li>
<li>Put the overwrite value of the saved EBP next, at the offset <code>0x15d</code>. This should be overwritten with any non-zero values, let&rsquo;s put <code>0xdeadf00d</code> there for additional points of style;</li>
<li>Put the return address next, at the offset <code>0x161</code>. We&rsquo;ll figure it&rsquo;s value a tiny bit later.</li>
<li>Put a zero byte next, at the offset <code>0x165</code> to finally terminate the string. In our case, we don&rsquo;t need to copy any more bytes;</li>
<li>Put a reasonably large NOP slide somewhere in the rest of the file followed by the shellcode. Since we don&rsquo;t directly control the address in memory where the whole savefile is loaded, it&rsquo;s better to have a NOP slide in case the data moves a bit in memory.</li>
</ul>
<p>Now let&rsquo;s go back to the return address. The savefile is loaded to the address <code>0x00429bd2</code>. By picking the address of the middle of the NOP slide in the savefile and adding it to the address above, I got a value of <code>0x00429bd2</code>. This creates a problem for us. Since the x86 CPU is little-endian, the address would be written backwards in the file, like <code>d2 8b 42 00</code> (as well as the rest of the values). As we remember, we can&rsquo;t include zero bytes in the string, since this is a string terminator. However, this is the last byte that we need to copy, so that should be fine, it will be both the most significant byte of the address and the string terminator.</p>
<p>This is what the end result looks like:</p>
<p><img class="img-zoomable" src="/xbox-frogger-beyond-exploit/savefile1.png" alt="1" />
</p>
<p>(Note that all the addresses are written as little-endian values)</p>
<p>So, let&rsquo;s sign our carefully crafted savefile, transfer it to the console and boot the game.</p>
<p>Unfortunately, the game just hangs after trying to load the savefile. The debugger shows that the game tries to execute something from the invalid address <code>0x3f429bd2</code> which crashes the system.</p>
<p>Wait, why did the most significant byte become <code>0x3f</code> instead of <code>0x00</code>? Let&rsquo;s take a look at the <code>format</code> parameter of the <code>my_sprintf</code>. Its value is <code>&quot;Confirm Load of %s?&quot;</code>, and as you can see, a question mark is added right after the string we&rsquo;re controlling. The most significant byte of the return address effectively terminates our string, and the <code>sprintf</code> happily adds a question mark right after, which ASCII code is, as you may have guessed, <code>0x3f</code>! This single byte is literally the only thing that blocks us from exploiting the executable like that. Let&rsquo;s see what else can we do.</p>
<h2 id="plan-b-bootstrap-loader">Plan B: bootstrap loader</h2>
<p>The nice property of the stack is that it&rsquo;s located in the part of the address space way above the address <code>0x00xxxxxx</code>. We can write a small bootstrap loader that will construct the desired address in memory and jump there. The most important property of this bootstrap is not to contain zero bytes, so we can copy it to the stack as part of the string.</p>
<p>This is the code I ended up with:</p>
<pre><code class="language-nasm">mov eax, 0FEEDC0DEh
mov ebx, 0FEAF5B0Ch
xor eax, ebx
jmp eax
</code></pre>
<p>The address is stored as a product of XORing it with a constant (<code>0xfeedc0de xor 0x00429bd2 = 0xfeaf5b0c</code>). Since <code>(a xor b) xor b = a</code> the address is recovered by XORing the product with the same constant once again. After that, it&rsquo;s just a matter of jumping to the recovered address. The compiled bootstrap looks like <code>b8 de c0 ed fe bb 0c 5b af fe 31 d8 ff e0</code>, so it perfectly matches the requirement of not having any zero bytes.</p>
<h2 id="returning-to-shellcode-take-2">Returning to shellcode, take 2</h2>
<p>Now we&rsquo;re gonna do the following:</p>
<ul>
<li>Include the bootstrap loader as part of the copied string;</li>
<li>Figure out its location in the stack with the debugger and put this address into the overwritten return address.</li>
</ul>
<p>This is how it looks like:</p>
<p><img class="img-zoomable" src="/xbox-frogger-beyond-exploit/savefile2.png" alt="1" />
</p>
<p>After booting the game and trying to load the resultant savefile, I was greeted with a <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/bug-check-0x7f--unexpected-kernel-mode-trap" target="_blank">kernel exception <code>UNEXPECTED_KERNEL_MODE_TRAP</code></a> with the first parameter meaning &ldquo;Double fault&rdquo;:</p>
<p><img class="img-zoomable" src="/xbox-frogger-beyond-exploit/invalid_address_return.png" alt="1" />
</p>
<p>The return address however has been overwritten correctly, so the problem lies in a different place.
(To be presice, I got this exception previous time as well. However, it wasn&rsquo;t really important there.)</p>
<h2 id="xbox-address-space">Xbox address space</h2>
<p>The retail Xbox has 64 MB of RAM, mapped from <code>0x00000000</code> to <code>0x03ffffff</code>. Stack addresses are clearly out of this range, which means that those are virtual addresses. This leads us to the conclusion that the Xbox kernel doesn&rsquo;t support executing the code from the virtual addresses, so we have to stick to the physical addresses.</p>
<p>Since we can&rsquo;t return to the address containing zero bytes, the first accessible address is <code>0x01010101</code>, located at 16-something MB from the beginning. Excluding the rest of the addresses containing zero byte, we have the access to around ~40 MB of RAM.</p>
<p>The possible next steps would be:</p>
<ul>
<li>Looking for the gadgets in the accessible areas of RAM and constructing the ROP chain (however, there&rsquo;s no guarantee that the values used for gadgets are gonna be the same on every system and on every boot);</li>
<li>Finding another vulnerability we can leverage.</li>
</ul>
<p>Let&rsquo;s try the second option and see where it will lead us.</p>
<h2 id="looking-for-another-vulnerability">Looking for another vulnerability</h2>
<p>After taking a break and looking at the <code>my_presentAlert</code> function with fresh eyes, it hit me - we control the value of <code>this</code>, and the function does some writes to the addresses relative to it.
Let&rsquo;s recap the passed parameters and the decompiled function itself:</p>
<ul>
<li><code>this</code>: pointer that we control</li>
<li><code>selector</code>: 2</li>
<li><code>message</code>: pointer to the string that we control</li>
<li><code>unknown1</code>: 0</li>
<li><code>unknown2</code>: 0</li>
</ul>
<p><img class="img-zoomable" src="/xbox-frogger-beyond-exploit/decompile2.png" alt="1" />
</p>
<p>At first, I was examining if I can leverage single-byte writes to the relative offsets <code>0x1c</code>-<code>0x1f</code> and <code>0x27</code>, but they were barely useable in the given situation.
And then I noticed the line 29. This call to <code>_strcpy</code> does precisely what you think - it copies the string we control to the address we control! This is a huge one! Let&rsquo;s see how we can leverage it.</p>
<h2 id="returning-to-shellcode-take-3">Returning to shellcode, take 3</h2>
<p>Our course of action would be:</p>
<ul>
<li>To find a place in RAM where we can write our string containing the bootstrap;</li>
<li>The rest at this point is obvious.</li>
</ul>
<p>For the kicks and giggles, I tried overwriting the value of this with the first available physical address, <code>0x01010101</code>. This is what I saw with the debugger:</p>
<p><img class="img-zoomable" src="/xbox-frogger-beyond-exploit/arbitrary_write.png" alt="1" />
</p>
<p>The arbitrary write worked! The selected area is nothing but our bootstrap loader! Perfect!</p>
<p>Now we can do the following:</p>
<ul>
<li>Overwrite <code>this_</code> with <code>0x01010101</code>;</li>
<li>Figure out the address of the shellcode in the string copied to the physical address, and overwrite the return address with this value. In my case, it was <code>0x01010281</code> (can be figured out with a debugger or calculated manually by adding the offset in the <code>_strcpy</code> call (<code>0x51</code>), length of the format string before the <code>%s</code> in the <code>my_sprintf</code> call (<code>0x10</code>), and the offset to the bootstrap from the beginning of the string in the savefile (in my case, <code>0x11f</code>) to the value of <code>this_</code>).</li>
</ul>
<p>Finally, it worked! Here&rsquo;s a short demo of the exploit in action:</p>

<div class="youtube-video">
  <iframe src="https://www.youtube.com/embed/Y57uZ8QvkYU" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video"></iframe>
</div>

<p>This is how the final savefile looks like:</p>
<p><img class="img-zoomable" src="/xbox-frogger-beyond-exploit/final_savefile.png" alt="1" />
</p>
<p>The missing part only contains the rest of the NOP slide.
Sources of the exploit can be found <a href="https://github.com/agarmash/FroggerBeyondExploit/tree/master/source" target="_blank">here</a>, as well as the <a href="https://github.com/agarmash/FroggerBeyondExploit/tree/master/ready_to_go_savefile/" target="_blank">ready to use exploit</a>.</p>
<p>Please note that I tested the exploit on the modified Xbox. If you try to use it on a vanilla Xbox and something doesn&rsquo;t work, let me know so we can fix it for everyone. If it works, let me know as well :)</p>
<h2 id="what-can-be-done-differently">What can be done differently</h2>
<p>Instead of copying the bootstrap loader to the chosen place in RAM, we can copy the whole shellcode. However, it shouldn&rsquo;t contain any zero bytes, so it should be prepared for that at first.</p>
<p>The very first thing in our shellcode is a <a href="https://community.netwitness.com/t5/netwitness-community-blog/network-detection-of-x86-buffer-overflow-shellcode/ba-p/518621" target="_blank">call with no offset</a>, which is compiled to <code>e8 00 00 00 00</code>. It&rsquo;s possible to <a href="https://twitter.com/re_and_more/status/1524630534248439808" target="_blank">replace this code with the one that doesn&rsquo;t contain zero bytes</a>, and that would be a good solution. However, there are many other &ldquo;holes&rdquo; in the compiled shellcode, and working them around one-by-one would require a lot of additional labor. What we can do instead is find a byte that never occurs in the rest of the compiled shellcode, XOR this part of the shellcode with this byte (which will effectively change all bytes in the binary to a non-zero ones), and write a small loader what will XOR the whole shellcode back before executing. This is precisely what the Splinter Cell exploit does:</p>
<p><img class="img-zoomable" src="/xbox-frogger-beyond-exploit/sc_xor_decryptor.png" alt="1" />
</p>
<p>After that, the exploit is just copied as part of the string to the chosen place in RAM and executed. Theoretically, this approach should be more reliable since we control where to copy the shellcode. So if the exploit doesn&rsquo;t work on some of the consoles, there&rsquo;s a clear idea on how to fix it.</p>
<h2 id="links">Links</h2>
<ul>
<li><a href="https://github.com/agarmash/FroggerBeyondExploit" target="_blank">GitHub repo with the compiled exploit, source files, and the decryptors for the 007 and Splinter Cell exploits</a></li>
</ul>
<h2 id="credits">Credits</h2>
<p>Big thanks to:</p>
<ul>
<li>Derf, dj0wns and Thrimbor for their help with the project;</li>
<li>XboxDev community in general for being an amazing place.</li>
</ul>
<h2 id="further-reading">Further reading</h2>
<ul>
<li><a href="https://xboxdevwiki.net/17_Mistakes_Microsoft_Made_in_the_Xbox_Security_System" target="_blank">&ldquo;17 Mistakes Microsoft Made in the Xbox Security System&rdquo; by Michael Steil</a>;</li>
<li><a href="https://web.archive.org/web/20031003093240/http://xbox-linux.sourceforge.net/docs/007analysis.html" target="_blank">Technical Analysis of 007: Agent Under Fire save game hack</a></li>
</ul>
    </div>
</article>



<div class="post-comment" data-comment="utterances">
    <span class="post-comment-notloaded">
        <i class="iconfont icon-chatbox-ellipses-sharp"></i>&nbsp;Load comments
    </span>
    <script>
        function loadComment() {
            var commentArea = document.querySelector('.post-comment');
            var utterancesTheme = document.body.getAttribute('data-theme');
            if (utterancesTheme === 'auto') {
                utterancesTheme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'photon-dark' :
                    'github-light';
            } else {
                utterancesTheme = utterancesTheme === 'dark' ? 'photon-dark' : 'github-light';
            }
            var s = document.createElement('script');
            s.src = 'https://utteranc.es/client.js';
            s.setAttribute('repo', 'agarmash\/agarmash.github.io');
            s.setAttribute('issue-term', 'pathname');
            s.setAttribute('label', 'Comments');
            s.setAttribute('theme', utterancesTheme);
            s.setAttribute('crossorigin', 'anonymous');
            s.setAttribute('async', '');
            document.querySelector('.post-comment').appendChild(s);
            document.querySelector('span.post-comment-notloaded').setAttribute('style', 'display: none;');
        }

        loadComment()
    </script>
</div>


            </div>
            <aside class="col-12 col-md-3 float-left sidebar">
    
    <div class="sidebar-item sidebar-pages">
        <h3>Pages</h3>
        <ul>
            
            <li>
                <a href="/">Home</a>
            </li>
            
            <li>
                <a href="/about/">About me</a>
            </li>
            
            <li>
                <a href="/index.xml">RSS</a>
            </li>
            
        </ul>
    </div>
    
    <div class="sidebar-item sidebar-tags">
        <h3>Tags</h3>
        <div>
            
            <span>
                <a href="/tags/avaudioplayer/">AVAudioPlayer</a>
            </span>
            
            <span>
                <a href="/tags/avfoundation/">AVFoundation</a>
            </span>
            
            <span>
                <a href="/tags/avr/">AVR</a>
            </span>
            
            <span>
                <a href="/tags/c/">C</a>
            </span>
            
            <span>
                <a href="/tags/ctf/">CTF</a>
            </span>
            
            <span>
                <a href="/tags/exploitation/">Exploitation</a>
            </span>
            
            <span>
                <a href="/tags/hackthebox/">HackTheBox</a>
            </span>
            
            <span>
                <a href="/tags/ipod/">iPod</a>
            </span>
            
            <span>
                <a href="/tags/reverse-engineering/">Reverse Engineering</a>
            </span>
            
            <span>
                <a href="/tags/rockbox/">Rockbox</a>
            </span>
            
            <span>
                <a href="/tags/ssd/">SSD</a>
            </span>
            
            <span>
                <a href="/tags/swift/">Swift</a>
            </span>
            
            <span>
                <a href="/tags/uiprogressview/">UIProgressView</a>
            </span>
            
            <span>
                <a href="/tags/uislider/">UISlider</a>
            </span>
            
            <span>
                <a href="/tags/writeup/">Writeup</a>
            </span>
            
            <span>
                <a href="/tags/xbox/">Xbox</a>
            </span>
            
        </div>
    </div>
    
    <div class="sidebar-item sidebar-links">
        <h3>Links</h3>
        <ul>
            
            <li>
                <a href="https://github.com/agarmash" target="_blank"><span>GitHub</span></a>
            </li>
            
            <li>
                <a href="https://www.linkedin.com/in/artem-garmash/" target="_blank"><span>LinkedIn</span></a>
            </li>
            
            <li>
                <a href="https://twitter.com/agarmash_" target="_blank"><span>Twitter</span></a>
            </li>
            
            <li>
                <a href="https://stackoverflow.com/users/7696358/artem-garmash" target="_blank"><span>Stack Overflow</span></a>
            </li>
            
            <li>
                <a href="https://www.strava.com/athletes/47538392" target="_blank"><span>Strava</span></a>
            </li>
            
            <li>
                <a href="https://www.last.fm/user/arch_saint" target="_blank"><span>Last.fm</span></a>
            </li>
            
        </ul>
    </div>
    
    
    
    <div class="sidebar-item sidebar-toc">
        <h3>TOC</h3>
        <nav id="TableOfContents">
  <ul>
    <li><a href="#attack-surface">Attack surface</a></li>
    <li><a href="#existing-savefile-exploits">Existing savefile exploits</a></li>
    <li><a href="#prerequisite-debug-hardware">Prerequisite: debug hardware</a></li>
    <li><a href="#examining-the-game-for-a-possible-overflow">Examining the game for a possible overflow</a></li>
    <li><a href="#examining-the-executable-internals">Examining the executable internals</a></li>
    <li><a href="#shellcode">Shellcode</a></li>
    <li><a href="#choosing-a-shellcode">Choosing a shellcode</a></li>
    <li><a href="#returning-to-shellcode">Returning to shellcode</a></li>
    <li><a href="#plan-b-bootstrap-loader">Plan B: bootstrap loader</a></li>
    <li><a href="#returning-to-shellcode-take-2">Returning to shellcode, take 2</a></li>
    <li><a href="#xbox-address-space">Xbox address space</a></li>
    <li><a href="#looking-for-another-vulnerability">Looking for another vulnerability</a></li>
    <li><a href="#returning-to-shellcode-take-3">Returning to shellcode, take 3</a></li>
    <li><a href="#what-can-be-done-differently">What can be done differently</a></li>
    <li><a href="#links">Links</a></li>
    <li><a href="#credits">Credits</a></li>
    <li><a href="#further-reading">Further reading</a></li>
  </ul>
</nav>

        <div style="margin-top: 1rem;">
            <a href='https://ko-fi.com/agarmash' target='_blank'><img height='36' style='border:0px;height:36px;' src='https://cdn.ko-fi.com/cdn/kofi2.png?v=3' border='0' alt='Buy Me a Coffee at ko-fi.com' /></a>
        </div>
    </div>
    
    
</aside>
        </div>
        <div class="btn">
    <div class="btn-toggle-mode">
        <i class="iconfont icon-contrast-sharp"></i>
    </div>
    <div class="btn-scroll-top">
        <i class="iconfont icon-chevron-up-circle-sharp"></i>
    </div>
</div>
    </main>

    <footer>
    <div class="container-lg clearfix">
        <div class="col-12 footer">
            <span>&copy; 2022 <a href="https://agarmash.com">Artem Garmash</a> |
                Powered by <a href="https://gohugo.io/"
                target="_blank">Hugo</a> & modified <a href="https://github.com/amzrk2/hugo-theme-fuji/"
                   target="_blank">Fuji-v2</a> </span>
        </div>
    </div>
</footer>
    
<script defer src="https://cdn.jsdelivr.net/combine/npm/medium-zoom@1.0.6,npm/lazysizes@5.2.2"></script>
<script defer src="https://cdn.jsdelivr.net/npm/prismjs@1.21.0/components/prism-core.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/prismjs@1.21.0/plugins/autoloader/prism-autoloader.min.js"></script>



<script defer src="/assets/js/fuji.min.js"></script>


</body>

</html>